// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: builder.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createImage = `-- name: CreateImage :exec
INSERT INTO images (id, registry, repository, tag, digest, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
`

type CreateImageParams struct {
	ID         pgtype.UUID `json:"id"`
	Registry   string      `json:"registry"`
	Repository string      `json:"repository"`
	Tag        string      `json:"tag"`
	Digest     string      `json:"digest"`
}

// Create new image record
func (q *Queries) CreateImage(ctx context.Context, arg *CreateImageParams) error {
	_, err := q.db.Exec(ctx, createImage,
		arg.ID,
		arg.Registry,
		arg.Repository,
		arg.Tag,
		arg.Digest,
	)
	return err
}

const getGithubInstallationByID = `-- name: GetGithubInstallationByID :one
SELECT id, user_id, github_account_id, github_installation_id, organisation_id, created_at, updated_at, deleted_at
FROM github_installations
WHERE id = $1
  AND deleted_at IS NULL
`

// Get GitHub installation details
func (q *Queries) GetGithubInstallationByID(ctx context.Context, id pgtype.UUID) (*GithubInstallation, error) {
	row := q.db.QueryRow(ctx, getGithubInstallationByID, id)
	var i GithubInstallation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubAccountID,
		&i.GithubInstallationID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getPendingBuild = `-- name: GetPendingBuild :one

SELECT id, status, project_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at, github_commit, github_branch
FROM builds
WHERE status = 'queued'
  AND deleted_at IS NULL
ORDER BY created_at ASC
LIMIT 1
FOR UPDATE SKIP LOCKED
`

// BUILDER QUERIES
// Get next pending build with row-level locking
func (q *Queries) GetPendingBuild(ctx context.Context) (*Build, error) {
	row := q.db.QueryRow(ctx, getPendingBuild)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProjectID,
		&i.ImageID,
		&i.VmID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.GithubCommit,
		&i.GithubBranch,
	)
	return &i, err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, name, slug, github_repository, github_installation_id, organisation_id, created_at, updated_at, deleted_at
FROM projects
WHERE id = $1
  AND deleted_at IS NULL
`

// Get project by ID
func (q *Queries) GetProjectByID(ctx context.Context, id pgtype.UUID) (*Project, error) {
	row := q.db.QueryRow(ctx, getProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.GithubRepository,
		&i.GithubInstallationID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const markBuildBuilding = `-- name: MarkBuildBuilding :exec
UPDATE builds
SET status = 'building',
    updated_at = NOW()
WHERE id = $1
`

// Mark build as building
func (q *Queries) MarkBuildBuilding(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markBuildBuilding, id)
	return err
}

const markBuildError = `-- name: MarkBuildError :exec
UPDATE builds
SET status = 'error',
    updated_at = NOW()
WHERE id = $1
`

// Mark build as error
func (q *Queries) MarkBuildError(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markBuildError, id)
	return err
}

const markBuildReady = `-- name: MarkBuildReady :exec
UPDATE builds
SET status = 'ready',
    image_id = $2,
    updated_at = NOW()
WHERE id = $1
`

type MarkBuildReadyParams struct {
	ID      pgtype.UUID `json:"id"`
	ImageID pgtype.UUID `json:"image_id"`
}

// Mark build as ready with image_id
func (q *Queries) MarkBuildReady(ctx context.Context, arg *MarkBuildReadyParams) error {
	_, err := q.db.Exec(ctx, markBuildReady, arg.ID, arg.ImageID)
	return err
}

const updateBuildVM = `-- name: UpdateBuildVM :exec
UPDATE builds
SET vm_id = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateBuildVMParams struct {
	ID   pgtype.UUID `json:"id"`
	VmID pgtype.UUID `json:"vm_id"`
}

// Assign VM to build
func (q *Queries) UpdateBuildVM(ctx context.Context, arg *UpdateBuildVMParams) error {
	_, err := q.db.Exec(ctx, updateBuildVM, arg.ID, arg.VmID)
	return err
}
