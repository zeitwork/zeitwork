// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: nodes.sql

package database

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const nodeCreate = `-- name: NodeCreate :one
INSERT INTO nodes (
    region_id, hostname, ip_address, state, resources
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, region_id, hostname, ip_address, state, resources, created_at, updated_at, deleted_at
`

type NodeCreateParams struct {
	RegionID  pgtype.UUID     `json:"region_id"`
	Hostname  string          `json:"hostname"`
	IpAddress string          `json:"ip_address"`
	State     string          `json:"state"`
	Resources json.RawMessage `json:"resources"`
}

func (q *Queries) NodeCreate(ctx context.Context, arg *NodeCreateParams) (*Node, error) {
	row := q.db.QueryRow(ctx, nodeCreate,
		arg.RegionID,
		arg.Hostname,
		arg.IpAddress,
		arg.State,
		arg.Resources,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.Hostname,
		&i.IpAddress,
		&i.State,
		&i.Resources,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const nodeDelete = `-- name: NodeDelete :exec
DELETE FROM nodes WHERE id = $1
`

func (q *Queries) NodeDelete(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, nodeDelete, id)
	return err
}

const nodeFind = `-- name: NodeFind :many
SELECT id, region_id, hostname, ip_address, state, resources, created_at, updated_at, deleted_at FROM nodes ORDER BY created_at DESC
`

func (q *Queries) NodeFind(ctx context.Context) ([]*Node, error) {
	rows, err := q.db.Query(ctx, nodeFind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.RegionID,
			&i.Hostname,
			&i.IpAddress,
			&i.State,
			&i.Resources,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nodeFindByHostname = `-- name: NodeFindByHostname :one
SELECT id, region_id, hostname, ip_address, state, resources, created_at, updated_at, deleted_at FROM nodes WHERE hostname = $1
`

func (q *Queries) NodeFindByHostname(ctx context.Context, hostname string) (*Node, error) {
	row := q.db.QueryRow(ctx, nodeFindByHostname, hostname)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.Hostname,
		&i.IpAddress,
		&i.State,
		&i.Resources,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const nodeFindById = `-- name: NodeFindById :one
SELECT id, region_id, hostname, ip_address, state, resources, created_at, updated_at, deleted_at FROM nodes WHERE id = $1
`

func (q *Queries) NodeFindById(ctx context.Context, id pgtype.UUID) (*Node, error) {
	row := q.db.QueryRow(ctx, nodeFindById, id)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.Hostname,
		&i.IpAddress,
		&i.State,
		&i.Resources,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const nodeFindByRegion = `-- name: NodeFindByRegion :many
SELECT id, region_id, hostname, ip_address, state, resources, created_at, updated_at, deleted_at FROM nodes WHERE region_id = $1 ORDER BY created_at DESC
`

func (q *Queries) NodeFindByRegion(ctx context.Context, regionID pgtype.UUID) ([]*Node, error) {
	rows, err := q.db.Query(ctx, nodeFindByRegion, regionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.RegionID,
			&i.Hostname,
			&i.IpAddress,
			&i.State,
			&i.Resources,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nodeFindByState = `-- name: NodeFindByState :many
SELECT id, region_id, hostname, ip_address, state, resources, created_at, updated_at, deleted_at FROM nodes WHERE state = $1
`

func (q *Queries) NodeFindByState(ctx context.Context, state string) ([]*Node, error) {
	rows, err := q.db.Query(ctx, nodeFindByState, state)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.RegionID,
			&i.Hostname,
			&i.IpAddress,
			&i.State,
			&i.Resources,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nodeUpdate = `-- name: NodeUpdate :one
UPDATE nodes 
SET 
    ip_address = COALESCE($2, ip_address),
    state = COALESCE($3, state),
    resources = COALESCE($4, resources),
    updated_at = NOW()
WHERE id = $1
RETURNING id, region_id, hostname, ip_address, state, resources, created_at, updated_at, deleted_at
`

type NodeUpdateParams struct {
	ID        pgtype.UUID     `json:"id"`
	IpAddress string          `json:"ip_address"`
	State     string          `json:"state"`
	Resources json.RawMessage `json:"resources"`
}

func (q *Queries) NodeUpdate(ctx context.Context, arg *NodeUpdateParams) (*Node, error) {
	row := q.db.QueryRow(ctx, nodeUpdate,
		arg.ID,
		arg.IpAddress,
		arg.State,
		arg.Resources,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.Hostname,
		&i.IpAddress,
		&i.State,
		&i.Resources,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const nodeUpdateResources = `-- name: NodeUpdateResources :one
UPDATE nodes SET resources = $2, updated_at = NOW() WHERE id = $1 RETURNING id, region_id, hostname, ip_address, state, resources, created_at, updated_at, deleted_at
`

type NodeUpdateResourcesParams struct {
	ID        pgtype.UUID     `json:"id"`
	Resources json.RawMessage `json:"resources"`
}

func (q *Queries) NodeUpdateResources(ctx context.Context, arg *NodeUpdateResourcesParams) (*Node, error) {
	row := q.db.QueryRow(ctx, nodeUpdateResources, arg.ID, arg.Resources)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.Hostname,
		&i.IpAddress,
		&i.State,
		&i.Resources,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const nodeUpdateState = `-- name: NodeUpdateState :one
UPDATE nodes SET state = $2, updated_at = NOW() WHERE id = $1 RETURNING id, region_id, hostname, ip_address, state, resources, created_at, updated_at, deleted_at
`

type NodeUpdateStateParams struct {
	ID    pgtype.UUID `json:"id"`
	State string      `json:"state"`
}

func (q *Queries) NodeUpdateState(ctx context.Context, arg *NodeUpdateStateParams) (*Node, error) {
	row := q.db.QueryRow(ctx, nodeUpdateState, arg.ID, arg.State)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.Hostname,
		&i.IpAddress,
		&i.State,
		&i.Resources,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
