// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: domains.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const domainsCreate = `-- name: DomainsCreate :one
INSERT INTO domains (
    id,
    name,
    verification_token,
    deployment_id,
    internal,
    organisation_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
RETURNING 
    id,
    name,
    verification_token,
    verified_at,
    deployment_id,
    internal,
    organisation_id,
    created_at,
    updated_at
`

type DomainsCreateParams struct {
	ID                pgtype.UUID `json:"id"`
	Name              string      `json:"name"`
	VerificationToken pgtype.Text `json:"verification_token"`
	DeploymentID      pgtype.UUID `json:"deployment_id"`
	Internal          bool        `json:"internal"`
	OrganisationID    pgtype.UUID `json:"organisation_id"`
}

type DomainsCreateRow struct {
	ID                pgtype.UUID        `json:"id"`
	Name              string             `json:"name"`
	VerificationToken pgtype.Text        `json:"verification_token"`
	VerifiedAt        pgtype.Timestamptz `json:"verified_at"`
	DeploymentID      pgtype.UUID        `json:"deployment_id"`
	Internal          bool               `json:"internal"`
	OrganisationID    pgtype.UUID        `json:"organisation_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// Create a new domain
func (q *Queries) DomainsCreate(ctx context.Context, arg *DomainsCreateParams) (*DomainsCreateRow, error) {
	row := q.db.QueryRow(ctx, domainsCreate,
		arg.ID,
		arg.Name,
		arg.VerificationToken,
		arg.DeploymentID,
		arg.Internal,
		arg.OrganisationID,
	)
	var i DomainsCreateRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.VerificationToken,
		&i.VerifiedAt,
		&i.DeploymentID,
		&i.Internal,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const domainsGetByDeployment = `-- name: DomainsGetByDeployment :many
SELECT 
    id,
    name,
    verification_token,
    verified_at,
    deployment_id,
    internal,
    organisation_id,
    created_at,
    updated_at
FROM domains 
WHERE deployment_id = $1 
    AND deleted_at IS NULL
`

type DomainsGetByDeploymentRow struct {
	ID                pgtype.UUID        `json:"id"`
	Name              string             `json:"name"`
	VerificationToken pgtype.Text        `json:"verification_token"`
	VerifiedAt        pgtype.Timestamptz `json:"verified_at"`
	DeploymentID      pgtype.UUID        `json:"deployment_id"`
	Internal          bool               `json:"internal"`
	OrganisationID    pgtype.UUID        `json:"organisation_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// Get domains by deployment
func (q *Queries) DomainsGetByDeployment(ctx context.Context, deploymentID pgtype.UUID) ([]*DomainsGetByDeploymentRow, error) {
	rows, err := q.db.Query(ctx, domainsGetByDeployment, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DomainsGetByDeploymentRow
	for rows.Next() {
		var i DomainsGetByDeploymentRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.VerificationToken,
			&i.VerifiedAt,
			&i.DeploymentID,
			&i.Internal,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const domainsGetById = `-- name: DomainsGetById :one
SELECT 
    id,
    name,
    verification_token,
    verified_at,
    deployment_id,
    internal,
    organisation_id,
    created_at,
    updated_at
FROM domains 
WHERE id = $1 
    AND deleted_at IS NULL
`

type DomainsGetByIdRow struct {
	ID                pgtype.UUID        `json:"id"`
	Name              string             `json:"name"`
	VerificationToken pgtype.Text        `json:"verification_token"`
	VerifiedAt        pgtype.Timestamptz `json:"verified_at"`
	DeploymentID      pgtype.UUID        `json:"deployment_id"`
	Internal          bool               `json:"internal"`
	OrganisationID    pgtype.UUID        `json:"organisation_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// Get domain by ID
func (q *Queries) DomainsGetById(ctx context.Context, id pgtype.UUID) (*DomainsGetByIdRow, error) {
	row := q.db.QueryRow(ctx, domainsGetById, id)
	var i DomainsGetByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.VerificationToken,
		&i.VerifiedAt,
		&i.DeploymentID,
		&i.Internal,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const domainsGetByName = `-- name: DomainsGetByName :one
SELECT 
    id,
    name,
    verification_token,
    verified_at,
    deployment_id,
    internal,
    organisation_id,
    created_at,
    updated_at
FROM domains 
WHERE name = $1 
    AND deleted_at IS NULL
`

type DomainsGetByNameRow struct {
	ID                pgtype.UUID        `json:"id"`
	Name              string             `json:"name"`
	VerificationToken pgtype.Text        `json:"verification_token"`
	VerifiedAt        pgtype.Timestamptz `json:"verified_at"`
	DeploymentID      pgtype.UUID        `json:"deployment_id"`
	Internal          bool               `json:"internal"`
	OrganisationID    pgtype.UUID        `json:"organisation_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// Get domain by name
func (q *Queries) DomainsGetByName(ctx context.Context, name string) (*DomainsGetByNameRow, error) {
	row := q.db.QueryRow(ctx, domainsGetByName, name)
	var i DomainsGetByNameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.VerificationToken,
		&i.VerifiedAt,
		&i.DeploymentID,
		&i.Internal,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const domainsListAll = `-- name: DomainsListAll :many
SELECT 
    id,
    name,
    verification_token,
    verified_at,
    deployment_id,
    internal,
    organisation_id,
    created_at,
    updated_at
FROM domains
WHERE deleted_at IS NULL
`

type DomainsListAllRow struct {
	ID                pgtype.UUID        `json:"id"`
	Name              string             `json:"name"`
	VerificationToken pgtype.Text        `json:"verification_token"`
	VerifiedAt        pgtype.Timestamptz `json:"verified_at"`
	DeploymentID      pgtype.UUID        `json:"deployment_id"`
	Internal          bool               `json:"internal"`
	OrganisationID    pgtype.UUID        `json:"organisation_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// List all domains regardless of verification
func (q *Queries) DomainsListAll(ctx context.Context) ([]*DomainsListAllRow, error) {
	rows, err := q.db.Query(ctx, domainsListAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DomainsListAllRow
	for rows.Next() {
		var i DomainsListAllRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.VerificationToken,
			&i.VerifiedAt,
			&i.DeploymentID,
			&i.Internal,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const domainsListVerified = `-- name: DomainsListVerified :many
SELECT 
    id,
    name,
    verification_token,
    verified_at,
    deployment_id,
    internal,
    organisation_id,
    created_at,
    updated_at
FROM domains
WHERE verified_at IS NOT NULL
  AND deleted_at IS NULL
`

type DomainsListVerifiedRow struct {
	ID                pgtype.UUID        `json:"id"`
	Name              string             `json:"name"`
	VerificationToken pgtype.Text        `json:"verification_token"`
	VerifiedAt        pgtype.Timestamptz `json:"verified_at"`
	DeploymentID      pgtype.UUID        `json:"deployment_id"`
	Internal          bool               `json:"internal"`
	OrganisationID    pgtype.UUID        `json:"organisation_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// List all verified domains
func (q *Queries) DomainsListVerified(ctx context.Context) ([]*DomainsListVerifiedRow, error) {
	rows, err := q.db.Query(ctx, domainsListVerified)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DomainsListVerifiedRow
	for rows.Next() {
		var i DomainsListVerifiedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.VerificationToken,
			&i.VerifiedAt,
			&i.DeploymentID,
			&i.Internal,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const domainsRepointToDeploymentForProjectEnv = `-- name: DomainsRepointToDeploymentForProjectEnv :execrows
UPDATE domains AS d
SET deployment_id = $3,
    updated_at = now()
FROM deployments AS dep
WHERE d.deployment_id = dep.id
  AND dep.project_id = $1
  AND dep.environment_id = $2
  AND d.internal = false
  AND d.verified_at IS NOT NULL
  AND d.deleted_at IS NULL
`

type DomainsRepointToDeploymentForProjectEnvParams struct {
	ProjectID     pgtype.UUID `json:"project_id"`
	EnvironmentID pgtype.UUID `json:"environment_id"`
	DeploymentID  pgtype.UUID `json:"deployment_id"`
}

// Repoint all verified, non-internal domains for a project+env to a deployment
func (q *Queries) DomainsRepointToDeploymentForProjectEnv(ctx context.Context, arg *DomainsRepointToDeploymentForProjectEnvParams) (int64, error) {
	result, err := q.db.Exec(ctx, domainsRepointToDeploymentForProjectEnv, arg.ProjectID, arg.EnvironmentID, arg.DeploymentID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const domainsVerify = `-- name: DomainsVerify :one
UPDATE domains 
SET verified_at = now(), 
    updated_at = now()
WHERE id = $1
RETURNING 
    id,
    name,
    verification_token,
    verified_at,
    deployment_id,
    internal,
    organisation_id,
    created_at,
    updated_at
`

type DomainsVerifyRow struct {
	ID                pgtype.UUID        `json:"id"`
	Name              string             `json:"name"`
	VerificationToken pgtype.Text        `json:"verification_token"`
	VerifiedAt        pgtype.Timestamptz `json:"verified_at"`
	DeploymentID      pgtype.UUID        `json:"deployment_id"`
	Internal          bool               `json:"internal"`
	OrganisationID    pgtype.UUID        `json:"organisation_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// Mark domain as verified
func (q *Queries) DomainsVerify(ctx context.Context, id pgtype.UUID) (*DomainsVerifyRow, error) {
	row := q.db.QueryRow(ctx, domainsVerify, id)
	var i DomainsVerifyRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.VerificationToken,
		&i.VerifiedAt,
		&i.DeploymentID,
		&i.Internal,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
