// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: deployments.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deploymentsCreate = `-- name: DeploymentsCreate :one
INSERT INTO deployments (
    id,
    deployment_id,
    status,
    commit_hash,
    project_id,
    environment_id,
    image_id,
    organisation_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
RETURNING 
    id,
    deployment_id,
    status,
    commit_hash,
    project_id,
    environment_id,
    image_id,
    organisation_id,
    created_at,
    updated_at
`

type DeploymentsCreateParams struct {
	ID             pgtype.UUID `json:"id"`
	DeploymentID   string      `json:"deployment_id"`
	Status         string      `json:"status"`
	CommitHash     string      `json:"commit_hash"`
	ProjectID      pgtype.UUID `json:"project_id"`
	EnvironmentID  pgtype.UUID `json:"environment_id"`
	ImageID        pgtype.UUID `json:"image_id"`
	OrganisationID pgtype.UUID `json:"organisation_id"`
}

type DeploymentsCreateRow struct {
	ID             pgtype.UUID        `json:"id"`
	DeploymentID   string             `json:"deployment_id"`
	Status         string             `json:"status"`
	CommitHash     string             `json:"commit_hash"`
	ProjectID      pgtype.UUID        `json:"project_id"`
	EnvironmentID  pgtype.UUID        `json:"environment_id"`
	ImageID        pgtype.UUID        `json:"image_id"`
	OrganisationID pgtype.UUID        `json:"organisation_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

// Create a new deployment
func (q *Queries) DeploymentsCreate(ctx context.Context, arg *DeploymentsCreateParams) (*DeploymentsCreateRow, error) {
	row := q.db.QueryRow(ctx, deploymentsCreate,
		arg.ID,
		arg.DeploymentID,
		arg.Status,
		arg.CommitHash,
		arg.ProjectID,
		arg.EnvironmentID,
		arg.ImageID,
		arg.OrganisationID,
	)
	var i DeploymentsCreateRow
	err := row.Scan(
		&i.ID,
		&i.DeploymentID,
		&i.Status,
		&i.CommitHash,
		&i.ProjectID,
		&i.EnvironmentID,
		&i.ImageID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deploymentsGetActiveRoutes = `-- name: DeploymentsGetActiveRoutes :many
SELECT 
    d.id as deployment_id,
    d.deployment_id as deployment_name,
    d.status,
    dom.name as domain,
    i.ipv6_address as ip_address,
    i.default_port,
    CASE 
        WHEN i.state = 'running' THEN true 
        ELSE false 
    END as healthy
FROM deployments d
JOIN domains dom ON dom.deployment_id = d.id
JOIN deployment_instances di ON di.deployment_id = d.id
JOIN instances i ON i.id = di.instance_id
WHERE d.status = 'active'
    AND dom.verified_at IS NOT NULL
    AND i.state IN ('running', 'starting')
    AND dom.deleted_at IS NULL
    AND d.deleted_at IS NULL
    AND i.deleted_at IS NULL
`

type DeploymentsGetActiveRoutesRow struct {
	DeploymentID   pgtype.UUID `json:"deployment_id"`
	DeploymentName string      `json:"deployment_name"`
	Status         string      `json:"status"`
	Domain         string      `json:"domain"`
	IpAddress      string      `json:"ip_address"`
	DefaultPort    int32       `json:"default_port"`
	Healthy        bool        `json:"healthy"`
}

// Get active deployment routes for edge proxy
func (q *Queries) DeploymentsGetActiveRoutes(ctx context.Context) ([]*DeploymentsGetActiveRoutesRow, error) {
	rows, err := q.db.Query(ctx, deploymentsGetActiveRoutes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DeploymentsGetActiveRoutesRow
	for rows.Next() {
		var i DeploymentsGetActiveRoutesRow
		if err := rows.Scan(
			&i.DeploymentID,
			&i.DeploymentName,
			&i.Status,
			&i.Domain,
			&i.IpAddress,
			&i.DefaultPort,
			&i.Healthy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentsGetById = `-- name: DeploymentsGetById :one
SELECT 
    id,
    deployment_id,
    status,
    commit_hash,
    project_id,
    environment_id,
    image_id,
    organisation_id,
    created_at,
    updated_at
FROM deployments 
WHERE id = $1 
    AND deleted_at IS NULL
`

type DeploymentsGetByIdRow struct {
	ID             pgtype.UUID        `json:"id"`
	DeploymentID   string             `json:"deployment_id"`
	Status         string             `json:"status"`
	CommitHash     string             `json:"commit_hash"`
	ProjectID      pgtype.UUID        `json:"project_id"`
	EnvironmentID  pgtype.UUID        `json:"environment_id"`
	ImageID        pgtype.UUID        `json:"image_id"`
	OrganisationID pgtype.UUID        `json:"organisation_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

// Get deployment by ID
func (q *Queries) DeploymentsGetById(ctx context.Context, id pgtype.UUID) (*DeploymentsGetByIdRow, error) {
	row := q.db.QueryRow(ctx, deploymentsGetById, id)
	var i DeploymentsGetByIdRow
	err := row.Scan(
		&i.ID,
		&i.DeploymentID,
		&i.Status,
		&i.CommitHash,
		&i.ProjectID,
		&i.EnvironmentID,
		&i.ImageID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deploymentsGetByProject = `-- name: DeploymentsGetByProject :many
SELECT 
    id,
    deployment_id,
    status,
    commit_hash,
    project_id,
    environment_id,
    image_id,
    organisation_id,
    created_at,
    updated_at
FROM deployments 
WHERE project_id = $1 
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

type DeploymentsGetByProjectRow struct {
	ID             pgtype.UUID        `json:"id"`
	DeploymentID   string             `json:"deployment_id"`
	Status         string             `json:"status"`
	CommitHash     string             `json:"commit_hash"`
	ProjectID      pgtype.UUID        `json:"project_id"`
	EnvironmentID  pgtype.UUID        `json:"environment_id"`
	ImageID        pgtype.UUID        `json:"image_id"`
	OrganisationID pgtype.UUID        `json:"organisation_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

// Get deployments by project ID
func (q *Queries) DeploymentsGetByProject(ctx context.Context, projectID pgtype.UUID) ([]*DeploymentsGetByProjectRow, error) {
	rows, err := q.db.Query(ctx, deploymentsGetByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DeploymentsGetByProjectRow
	for rows.Next() {
		var i DeploymentsGetByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.Status,
			&i.CommitHash,
			&i.ProjectID,
			&i.EnvironmentID,
			&i.ImageID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentsGetPendingWithoutBuilds = `-- name: DeploymentsGetPendingWithoutBuilds :many
SELECT 
    d.id,
    d.deployment_id,
    d.status,
    d.commit_hash,
    d.project_id,
    d.environment_id,
    d.image_id,
    d.organisation_id,
    d.created_at,
    d.updated_at,
    p.github_repository,
    p.default_branch
FROM deployments d
JOIN projects p ON p.id = d.project_id
LEFT JOIN image_builds ib ON ib.deployment_id = d.id
WHERE d.status = 'pending' 
    AND d.deleted_at IS NULL
    AND p.deleted_at IS NULL
    AND ib.id IS NULL
ORDER BY d.created_at ASC
`

type DeploymentsGetPendingWithoutBuildsRow struct {
	ID               pgtype.UUID        `json:"id"`
	DeploymentID     string             `json:"deployment_id"`
	Status           string             `json:"status"`
	CommitHash       string             `json:"commit_hash"`
	ProjectID        pgtype.UUID        `json:"project_id"`
	EnvironmentID    pgtype.UUID        `json:"environment_id"`
	ImageID          pgtype.UUID        `json:"image_id"`
	OrganisationID   pgtype.UUID        `json:"organisation_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	GithubRepository string             `json:"github_repository"`
	DefaultBranch    string             `json:"default_branch"`
}

// Get pending deployments that don't have any image builds yet
func (q *Queries) DeploymentsGetPendingWithoutBuilds(ctx context.Context) ([]*DeploymentsGetPendingWithoutBuildsRow, error) {
	rows, err := q.db.Query(ctx, deploymentsGetPendingWithoutBuilds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DeploymentsGetPendingWithoutBuildsRow
	for rows.Next() {
		var i DeploymentsGetPendingWithoutBuildsRow
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.Status,
			&i.CommitHash,
			&i.ProjectID,
			&i.EnvironmentID,
			&i.ImageID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GithubRepository,
			&i.DefaultBranch,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentsGetReadyForDeployment = `-- name: DeploymentsGetReadyForDeployment :many
SELECT 
    d.id,
    d.deployment_id,
    d.status,
    d.commit_hash,
    d.project_id,
    d.environment_id,
    d.image_id,
    d.organisation_id,
    d.created_at,
    d.updated_at,
    ib.id as build_id
FROM deployments d
JOIN image_builds ib ON ib.deployment_id = d.id
LEFT JOIN deployment_instances di ON di.deployment_id = d.id
WHERE d.status = 'deploying'
    AND ib.status = 'completed'
    AND d.deleted_at IS NULL
    AND di.id IS NULL
ORDER BY d.created_at ASC
`

type DeploymentsGetReadyForDeploymentRow struct {
	ID             pgtype.UUID        `json:"id"`
	DeploymentID   string             `json:"deployment_id"`
	Status         string             `json:"status"`
	CommitHash     string             `json:"commit_hash"`
	ProjectID      pgtype.UUID        `json:"project_id"`
	EnvironmentID  pgtype.UUID        `json:"environment_id"`
	ImageID        pgtype.UUID        `json:"image_id"`
	OrganisationID pgtype.UUID        `json:"organisation_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	BuildID        pgtype.UUID        `json:"build_id"`
}

// Get deployments that have completed builds but no instances yet (ready for deployment)
func (q *Queries) DeploymentsGetReadyForDeployment(ctx context.Context) ([]*DeploymentsGetReadyForDeploymentRow, error) {
	rows, err := q.db.Query(ctx, deploymentsGetReadyForDeployment)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DeploymentsGetReadyForDeploymentRow
	for rows.Next() {
		var i DeploymentsGetReadyForDeploymentRow
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.Status,
			&i.CommitHash,
			&i.ProjectID,
			&i.EnvironmentID,
			&i.ImageID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BuildID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentsUpdateImageId = `-- name: DeploymentsUpdateImageId :one
UPDATE deployments 
SET image_id = $2, 
    updated_at = now()
WHERE id = $1
RETURNING 
    id,
    deployment_id,
    status,
    commit_hash,
    project_id,
    environment_id,
    image_id,
    organisation_id,
    created_at,
    updated_at
`

type DeploymentsUpdateImageIdParams struct {
	ID      pgtype.UUID `json:"id"`
	ImageID pgtype.UUID `json:"image_id"`
}

type DeploymentsUpdateImageIdRow struct {
	ID             pgtype.UUID        `json:"id"`
	DeploymentID   string             `json:"deployment_id"`
	Status         string             `json:"status"`
	CommitHash     string             `json:"commit_hash"`
	ProjectID      pgtype.UUID        `json:"project_id"`
	EnvironmentID  pgtype.UUID        `json:"environment_id"`
	ImageID        pgtype.UUID        `json:"image_id"`
	OrganisationID pgtype.UUID        `json:"organisation_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

// Update deployment image_id after successful build
func (q *Queries) DeploymentsUpdateImageId(ctx context.Context, arg *DeploymentsUpdateImageIdParams) (*DeploymentsUpdateImageIdRow, error) {
	row := q.db.QueryRow(ctx, deploymentsUpdateImageId, arg.ID, arg.ImageID)
	var i DeploymentsUpdateImageIdRow
	err := row.Scan(
		&i.ID,
		&i.DeploymentID,
		&i.Status,
		&i.CommitHash,
		&i.ProjectID,
		&i.EnvironmentID,
		&i.ImageID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deploymentsUpdateStatus = `-- name: DeploymentsUpdateStatus :one
UPDATE deployments 
SET status = $2, 
    updated_at = now()
WHERE id = $1
RETURNING 
    id,
    deployment_id,
    status,
    commit_hash,
    project_id,
    environment_id,
    image_id,
    organisation_id,
    created_at,
    updated_at
`

type DeploymentsUpdateStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

type DeploymentsUpdateStatusRow struct {
	ID             pgtype.UUID        `json:"id"`
	DeploymentID   string             `json:"deployment_id"`
	Status         string             `json:"status"`
	CommitHash     string             `json:"commit_hash"`
	ProjectID      pgtype.UUID        `json:"project_id"`
	EnvironmentID  pgtype.UUID        `json:"environment_id"`
	ImageID        pgtype.UUID        `json:"image_id"`
	OrganisationID pgtype.UUID        `json:"organisation_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

// Update deployment status
func (q *Queries) DeploymentsUpdateStatus(ctx context.Context, arg *DeploymentsUpdateStatusParams) (*DeploymentsUpdateStatusRow, error) {
	row := q.db.QueryRow(ctx, deploymentsUpdateStatus, arg.ID, arg.Status)
	var i DeploymentsUpdateStatusRow
	err := row.Scan(
		&i.ID,
		&i.DeploymentID,
		&i.Status,
		&i.CommitHash,
		&i.ProjectID,
		&i.EnvironmentID,
		&i.ImageID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
