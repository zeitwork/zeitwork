// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ipv6.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const iPv6AllocationAllocate = `-- name: IPv6AllocationAllocate :one
UPDATE ipv6_allocations 
SET instance_id = $2, state = 'allocated', updated_at = NOW() 
WHERE id = $1 AND state IN ('released', 'reserved')
RETURNING id, region_id, node_id, instance_id, ipv6_address, prefix, state, created_at, updated_at, deleted_at
`

type IPv6AllocationAllocateParams struct {
	ID         pgtype.UUID `json:"id"`
	InstanceID pgtype.UUID `json:"instance_id"`
}

func (q *Queries) IPv6AllocationAllocate(ctx context.Context, arg *IPv6AllocationAllocateParams) (*Ipv6Allocation, error) {
	row := q.db.QueryRow(ctx, iPv6AllocationAllocate, arg.ID, arg.InstanceID)
	var i Ipv6Allocation
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.NodeID,
		&i.InstanceID,
		&i.Ipv6Address,
		&i.Prefix,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const iPv6AllocationCreate = `-- name: IPv6AllocationCreate :one
INSERT INTO ipv6_allocations (region_id, node_id, instance_id, ipv6_address, prefix, state) 
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, region_id, node_id, instance_id, ipv6_address, prefix, state, created_at, updated_at, deleted_at
`

type IPv6AllocationCreateParams struct {
	RegionID    pgtype.UUID `json:"region_id"`
	NodeID      pgtype.UUID `json:"node_id"`
	InstanceID  pgtype.UUID `json:"instance_id"`
	Ipv6Address string      `json:"ipv6_address"`
	Prefix      string      `json:"prefix"`
	State       string      `json:"state"`
}

func (q *Queries) IPv6AllocationCreate(ctx context.Context, arg *IPv6AllocationCreateParams) (*Ipv6Allocation, error) {
	row := q.db.QueryRow(ctx, iPv6AllocationCreate,
		arg.RegionID,
		arg.NodeID,
		arg.InstanceID,
		arg.Ipv6Address,
		arg.Prefix,
		arg.State,
	)
	var i Ipv6Allocation
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.NodeID,
		&i.InstanceID,
		&i.Ipv6Address,
		&i.Prefix,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const iPv6AllocationFindAvailable = `-- name: IPv6AllocationFindAvailable :many
SELECT id, region_id, node_id, instance_id, ipv6_address, prefix, state, created_at, updated_at, deleted_at FROM ipv6_allocations 
WHERE state = 'released' AND region_id = $1 
ORDER BY ipv6_address 
LIMIT $2
`

type IPv6AllocationFindAvailableParams struct {
	RegionID pgtype.UUID `json:"region_id"`
	Limit    int32       `json:"limit"`
}

func (q *Queries) IPv6AllocationFindAvailable(ctx context.Context, arg *IPv6AllocationFindAvailableParams) ([]*Ipv6Allocation, error) {
	rows, err := q.db.Query(ctx, iPv6AllocationFindAvailable, arg.RegionID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Ipv6Allocation
	for rows.Next() {
		var i Ipv6Allocation
		if err := rows.Scan(
			&i.ID,
			&i.RegionID,
			&i.NodeID,
			&i.InstanceID,
			&i.Ipv6Address,
			&i.Prefix,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const iPv6AllocationFindByAddress = `-- name: IPv6AllocationFindByAddress :one
SELECT id, region_id, node_id, instance_id, ipv6_address, prefix, state, created_at, updated_at, deleted_at FROM ipv6_allocations WHERE ipv6_address = $1
`

func (q *Queries) IPv6AllocationFindByAddress(ctx context.Context, ipv6Address string) (*Ipv6Allocation, error) {
	row := q.db.QueryRow(ctx, iPv6AllocationFindByAddress, ipv6Address)
	var i Ipv6Allocation
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.NodeID,
		&i.InstanceID,
		&i.Ipv6Address,
		&i.Prefix,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const iPv6AllocationFindById = `-- name: IPv6AllocationFindById :one
SELECT id, region_id, node_id, instance_id, ipv6_address, prefix, state, created_at, updated_at, deleted_at FROM ipv6_allocations WHERE id = $1
`

func (q *Queries) IPv6AllocationFindById(ctx context.Context, id pgtype.UUID) (*Ipv6Allocation, error) {
	row := q.db.QueryRow(ctx, iPv6AllocationFindById, id)
	var i Ipv6Allocation
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.NodeID,
		&i.InstanceID,
		&i.Ipv6Address,
		&i.Prefix,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const iPv6AllocationFindByInstance = `-- name: IPv6AllocationFindByInstance :one
SELECT id, region_id, node_id, instance_id, ipv6_address, prefix, state, created_at, updated_at, deleted_at FROM ipv6_allocations WHERE instance_id = $1
`

func (q *Queries) IPv6AllocationFindByInstance(ctx context.Context, instanceID pgtype.UUID) (*Ipv6Allocation, error) {
	row := q.db.QueryRow(ctx, iPv6AllocationFindByInstance, instanceID)
	var i Ipv6Allocation
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.NodeID,
		&i.InstanceID,
		&i.Ipv6Address,
		&i.Prefix,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const iPv6AllocationFindByNode = `-- name: IPv6AllocationFindByNode :many
SELECT id, region_id, node_id, instance_id, ipv6_address, prefix, state, created_at, updated_at, deleted_at FROM ipv6_allocations WHERE node_id = $1 ORDER BY ipv6_address
`

func (q *Queries) IPv6AllocationFindByNode(ctx context.Context, nodeID pgtype.UUID) ([]*Ipv6Allocation, error) {
	rows, err := q.db.Query(ctx, iPv6AllocationFindByNode, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Ipv6Allocation
	for rows.Next() {
		var i Ipv6Allocation
		if err := rows.Scan(
			&i.ID,
			&i.RegionID,
			&i.NodeID,
			&i.InstanceID,
			&i.Ipv6Address,
			&i.Prefix,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const iPv6AllocationFindByRegion = `-- name: IPv6AllocationFindByRegion :many
SELECT id, region_id, node_id, instance_id, ipv6_address, prefix, state, created_at, updated_at, deleted_at FROM ipv6_allocations WHERE region_id = $1 ORDER BY ipv6_address
`

func (q *Queries) IPv6AllocationFindByRegion(ctx context.Context, regionID pgtype.UUID) ([]*Ipv6Allocation, error) {
	rows, err := q.db.Query(ctx, iPv6AllocationFindByRegion, regionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Ipv6Allocation
	for rows.Next() {
		var i Ipv6Allocation
		if err := rows.Scan(
			&i.ID,
			&i.RegionID,
			&i.NodeID,
			&i.InstanceID,
			&i.Ipv6Address,
			&i.Prefix,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const iPv6AllocationRelease = `-- name: IPv6AllocationRelease :one
UPDATE ipv6_allocations 
SET instance_id = NULL, state = 'released', updated_at = NOW() 
WHERE id = $1 RETURNING id, region_id, node_id, instance_id, ipv6_address, prefix, state, created_at, updated_at, deleted_at
`

func (q *Queries) IPv6AllocationRelease(ctx context.Context, id pgtype.UUID) (*Ipv6Allocation, error) {
	row := q.db.QueryRow(ctx, iPv6AllocationRelease, id)
	var i Ipv6Allocation
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.NodeID,
		&i.InstanceID,
		&i.Ipv6Address,
		&i.Prefix,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const iPv6AllocationReserve = `-- name: IPv6AllocationReserve :one
UPDATE ipv6_allocations 
SET state = 'reserved', updated_at = NOW() 
WHERE id = $1 AND state = 'released'
RETURNING id, region_id, node_id, instance_id, ipv6_address, prefix, state, created_at, updated_at, deleted_at
`

func (q *Queries) IPv6AllocationReserve(ctx context.Context, id pgtype.UUID) (*Ipv6Allocation, error) {
	row := q.db.QueryRow(ctx, iPv6AllocationReserve, id)
	var i Ipv6Allocation
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.NodeID,
		&i.InstanceID,
		&i.Ipv6Address,
		&i.Prefix,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
