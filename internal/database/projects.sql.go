// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: projects.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const projectsCreate = `-- name: ProjectsCreate :one
INSERT INTO projects (
    id,
    name,
    slug,
    github_repository,
    default_branch,
    organisation_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
RETURNING 
    id,
    name,
    slug,
    github_repository,
    default_branch,
    latest_deployment_id,
    organisation_id,
    created_at,
    updated_at
`

type ProjectsCreateParams struct {
	ID               pgtype.UUID `json:"id"`
	Name             string      `json:"name"`
	Slug             string      `json:"slug"`
	GithubRepository string      `json:"github_repository"`
	DefaultBranch    string      `json:"default_branch"`
	OrganisationID   pgtype.UUID `json:"organisation_id"`
}

type ProjectsCreateRow struct {
	ID                 pgtype.UUID        `json:"id"`
	Name               string             `json:"name"`
	Slug               string             `json:"slug"`
	GithubRepository   string             `json:"github_repository"`
	DefaultBranch      string             `json:"default_branch"`
	LatestDeploymentID pgtype.UUID        `json:"latest_deployment_id"`
	OrganisationID     pgtype.UUID        `json:"organisation_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

// Create a new project
func (q *Queries) ProjectsCreate(ctx context.Context, arg *ProjectsCreateParams) (*ProjectsCreateRow, error) {
	row := q.db.QueryRow(ctx, projectsCreate,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.GithubRepository,
		arg.DefaultBranch,
		arg.OrganisationID,
	)
	var i ProjectsCreateRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.GithubRepository,
		&i.DefaultBranch,
		&i.LatestDeploymentID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const projectsGetById = `-- name: ProjectsGetById :one
SELECT 
    id,
    name,
    slug,
    github_repository,
    default_branch,
    latest_deployment_id,
    organisation_id,
    created_at,
    updated_at
FROM projects 
WHERE id = $1 
    AND deleted_at IS NULL
`

type ProjectsGetByIdRow struct {
	ID                 pgtype.UUID        `json:"id"`
	Name               string             `json:"name"`
	Slug               string             `json:"slug"`
	GithubRepository   string             `json:"github_repository"`
	DefaultBranch      string             `json:"default_branch"`
	LatestDeploymentID pgtype.UUID        `json:"latest_deployment_id"`
	OrganisationID     pgtype.UUID        `json:"organisation_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

// Get project by ID
func (q *Queries) ProjectsGetById(ctx context.Context, id pgtype.UUID) (*ProjectsGetByIdRow, error) {
	row := q.db.QueryRow(ctx, projectsGetById, id)
	var i ProjectsGetByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.GithubRepository,
		&i.DefaultBranch,
		&i.LatestDeploymentID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const projectsGetByOrganisation = `-- name: ProjectsGetByOrganisation :many
SELECT 
    id,
    name,
    slug,
    github_repository,
    default_branch,
    latest_deployment_id,
    organisation_id,
    created_at,
    updated_at
FROM projects 
WHERE organisation_id = $1 
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ProjectsGetByOrganisationRow struct {
	ID                 pgtype.UUID        `json:"id"`
	Name               string             `json:"name"`
	Slug               string             `json:"slug"`
	GithubRepository   string             `json:"github_repository"`
	DefaultBranch      string             `json:"default_branch"`
	LatestDeploymentID pgtype.UUID        `json:"latest_deployment_id"`
	OrganisationID     pgtype.UUID        `json:"organisation_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

// Get projects by organisation
func (q *Queries) ProjectsGetByOrganisation(ctx context.Context, organisationID pgtype.UUID) ([]*ProjectsGetByOrganisationRow, error) {
	rows, err := q.db.Query(ctx, projectsGetByOrganisation, organisationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ProjectsGetByOrganisationRow
	for rows.Next() {
		var i ProjectsGetByOrganisationRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.GithubRepository,
			&i.DefaultBranch,
			&i.LatestDeploymentID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectsGetBySlugAndOrg = `-- name: ProjectsGetBySlugAndOrg :one
SELECT 
    id,
    name,
    slug,
    github_repository,
    default_branch,
    latest_deployment_id,
    organisation_id,
    created_at,
    updated_at
FROM projects 
WHERE slug = $1 
    AND organisation_id = $2
    AND deleted_at IS NULL
`

type ProjectsGetBySlugAndOrgParams struct {
	Slug           string      `json:"slug"`
	OrganisationID pgtype.UUID `json:"organisation_id"`
}

type ProjectsGetBySlugAndOrgRow struct {
	ID                 pgtype.UUID        `json:"id"`
	Name               string             `json:"name"`
	Slug               string             `json:"slug"`
	GithubRepository   string             `json:"github_repository"`
	DefaultBranch      string             `json:"default_branch"`
	LatestDeploymentID pgtype.UUID        `json:"latest_deployment_id"`
	OrganisationID     pgtype.UUID        `json:"organisation_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

// Get project by slug and organisation
func (q *Queries) ProjectsGetBySlugAndOrg(ctx context.Context, arg *ProjectsGetBySlugAndOrgParams) (*ProjectsGetBySlugAndOrgRow, error) {
	row := q.db.QueryRow(ctx, projectsGetBySlugAndOrg, arg.Slug, arg.OrganisationID)
	var i ProjectsGetBySlugAndOrgRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.GithubRepository,
		&i.DefaultBranch,
		&i.LatestDeploymentID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const projectsUpdateLatestDeployment = `-- name: ProjectsUpdateLatestDeployment :one
UPDATE projects 
SET latest_deployment_id = $2, 
    updated_at = now()
WHERE id = $1
RETURNING 
    id,
    name,
    slug,
    github_repository,
    default_branch,
    latest_deployment_id,
    organisation_id,
    created_at,
    updated_at
`

type ProjectsUpdateLatestDeploymentParams struct {
	ID                 pgtype.UUID `json:"id"`
	LatestDeploymentID pgtype.UUID `json:"latest_deployment_id"`
}

type ProjectsUpdateLatestDeploymentRow struct {
	ID                 pgtype.UUID        `json:"id"`
	Name               string             `json:"name"`
	Slug               string             `json:"slug"`
	GithubRepository   string             `json:"github_repository"`
	DefaultBranch      string             `json:"default_branch"`
	LatestDeploymentID pgtype.UUID        `json:"latest_deployment_id"`
	OrganisationID     pgtype.UUID        `json:"organisation_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

// Update project's latest deployment
func (q *Queries) ProjectsUpdateLatestDeployment(ctx context.Context, arg *ProjectsUpdateLatestDeploymentParams) (*ProjectsUpdateLatestDeploymentRow, error) {
	row := q.db.QueryRow(ctx, projectsUpdateLatestDeployment, arg.ID, arg.LatestDeploymentID)
	var i ProjectsUpdateLatestDeploymentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.GithubRepository,
		&i.DefaultBranch,
		&i.LatestDeploymentID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
