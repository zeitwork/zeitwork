// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: projects.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const projectCreate = `-- name: ProjectCreate :one
INSERT INTO projects (name, slug, organisation_id) VALUES ($1, $2, $3) RETURNING id, name, slug, organisation_id, created_at, updated_at, deleted_at
`

type ProjectCreateParams struct {
	Name           string      `json:"name"`
	Slug           string      `json:"slug"`
	OrganisationID pgtype.UUID `json:"organisation_id"`
}

func (q *Queries) ProjectCreate(ctx context.Context, arg *ProjectCreateParams) (*Project, error) {
	row := q.db.QueryRow(ctx, projectCreate, arg.Name, arg.Slug, arg.OrganisationID)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const projectDelete = `-- name: ProjectDelete :exec
DELETE FROM projects WHERE id = $1
`

func (q *Queries) ProjectDelete(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, projectDelete, id)
	return err
}

const projectEnvironmentCreate = `-- name: ProjectEnvironmentCreate :one
INSERT INTO project_environments (project_id, name, organisation_id) VALUES ($1, $2, $3) RETURNING id, project_id, name, organisation_id, created_at, updated_at, deleted_at
`

type ProjectEnvironmentCreateParams struct {
	ProjectID      pgtype.UUID `json:"project_id"`
	Name           string      `json:"name"`
	OrganisationID pgtype.UUID `json:"organisation_id"`
}

func (q *Queries) ProjectEnvironmentCreate(ctx context.Context, arg *ProjectEnvironmentCreateParams) (*ProjectEnvironment, error) {
	row := q.db.QueryRow(ctx, projectEnvironmentCreate, arg.ProjectID, arg.Name, arg.OrganisationID)
	var i ProjectEnvironment
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const projectEnvironmentDelete = `-- name: ProjectEnvironmentDelete :exec
DELETE FROM project_environments WHERE id = $1
`

func (q *Queries) ProjectEnvironmentDelete(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, projectEnvironmentDelete, id)
	return err
}

const projectEnvironmentFindById = `-- name: ProjectEnvironmentFindById :one
SELECT id, project_id, name, organisation_id, created_at, updated_at, deleted_at FROM project_environments WHERE id = $1
`

func (q *Queries) ProjectEnvironmentFindById(ctx context.Context, id pgtype.UUID) (*ProjectEnvironment, error) {
	row := q.db.QueryRow(ctx, projectEnvironmentFindById, id)
	var i ProjectEnvironment
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const projectEnvironmentFindByName = `-- name: ProjectEnvironmentFindByName :one
SELECT id, project_id, name, organisation_id, created_at, updated_at, deleted_at FROM project_environments WHERE project_id = $1 AND name = $2
`

type ProjectEnvironmentFindByNameParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	Name      string      `json:"name"`
}

func (q *Queries) ProjectEnvironmentFindByName(ctx context.Context, arg *ProjectEnvironmentFindByNameParams) (*ProjectEnvironment, error) {
	row := q.db.QueryRow(ctx, projectEnvironmentFindByName, arg.ProjectID, arg.Name)
	var i ProjectEnvironment
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const projectEnvironmentFindByProject = `-- name: ProjectEnvironmentFindByProject :many
SELECT id, project_id, name, organisation_id, created_at, updated_at, deleted_at FROM project_environments WHERE project_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ProjectEnvironmentFindByProject(ctx context.Context, projectID pgtype.UUID) ([]*ProjectEnvironment, error) {
	rows, err := q.db.Query(ctx, projectEnvironmentFindByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ProjectEnvironment
	for rows.Next() {
		var i ProjectEnvironment
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectEnvironmentUpdate = `-- name: ProjectEnvironmentUpdate :one
UPDATE project_environments SET name = $2, updated_at = NOW() WHERE id = $1 RETURNING id, project_id, name, organisation_id, created_at, updated_at, deleted_at
`

type ProjectEnvironmentUpdateParams struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
}

func (q *Queries) ProjectEnvironmentUpdate(ctx context.Context, arg *ProjectEnvironmentUpdateParams) (*ProjectEnvironment, error) {
	row := q.db.QueryRow(ctx, projectEnvironmentUpdate, arg.ID, arg.Name)
	var i ProjectEnvironment
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const projectFind = `-- name: ProjectFind :many
SELECT id, name, slug, organisation_id, created_at, updated_at, deleted_at FROM projects ORDER BY created_at DESC
`

func (q *Queries) ProjectFind(ctx context.Context) ([]*Project, error) {
	rows, err := q.db.Query(ctx, projectFind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectFindByGitHubRepo = `-- name: ProjectFindByGitHubRepo :many
SELECT id, name, slug, organisation_id, created_at, updated_at, deleted_at FROM projects WHERE FALSE
`

// TODO: For now, return empty set. Need to add github_repo field to projects table
func (q *Queries) ProjectFindByGitHubRepo(ctx context.Context) ([]*Project, error) {
	rows, err := q.db.Query(ctx, projectFindByGitHubRepo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectFindById = `-- name: ProjectFindById :one
SELECT id, name, slug, organisation_id, created_at, updated_at, deleted_at FROM projects WHERE id = $1
`

func (q *Queries) ProjectFindById(ctx context.Context, id pgtype.UUID) (*Project, error) {
	row := q.db.QueryRow(ctx, projectFindById, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const projectFindByOrganisation = `-- name: ProjectFindByOrganisation :many
SELECT id, name, slug, organisation_id, created_at, updated_at, deleted_at FROM projects WHERE organisation_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ProjectFindByOrganisation(ctx context.Context, organisationID pgtype.UUID) ([]*Project, error) {
	rows, err := q.db.Query(ctx, projectFindByOrganisation, organisationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectFindBySlug = `-- name: ProjectFindBySlug :one
SELECT id, name, slug, organisation_id, created_at, updated_at, deleted_at FROM projects WHERE slug = $1
`

func (q *Queries) ProjectFindBySlug(ctx context.Context, slug string) (*Project, error) {
	row := q.db.QueryRow(ctx, projectFindBySlug, slug)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const projectSecretCreate = `-- name: ProjectSecretCreate :one
INSERT INTO project_secrets (project_id, name, value, organisation_id) VALUES ($1, $2, $3, $4) RETURNING id, project_id, name, value, organisation_id, created_at, updated_at, deleted_at
`

type ProjectSecretCreateParams struct {
	ProjectID      pgtype.UUID `json:"project_id"`
	Name           string      `json:"name"`
	Value          string      `json:"value"`
	OrganisationID pgtype.UUID `json:"organisation_id"`
}

func (q *Queries) ProjectSecretCreate(ctx context.Context, arg *ProjectSecretCreateParams) (*ProjectSecret, error) {
	row := q.db.QueryRow(ctx, projectSecretCreate,
		arg.ProjectID,
		arg.Name,
		arg.Value,
		arg.OrganisationID,
	)
	var i ProjectSecret
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Value,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const projectSecretDelete = `-- name: ProjectSecretDelete :exec
DELETE FROM project_secrets WHERE id = $1
`

func (q *Queries) ProjectSecretDelete(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, projectSecretDelete, id)
	return err
}

const projectSecretFindById = `-- name: ProjectSecretFindById :one
SELECT id, project_id, name, value, organisation_id, created_at, updated_at, deleted_at FROM project_secrets WHERE id = $1
`

func (q *Queries) ProjectSecretFindById(ctx context.Context, id pgtype.UUID) (*ProjectSecret, error) {
	row := q.db.QueryRow(ctx, projectSecretFindById, id)
	var i ProjectSecret
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Value,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const projectSecretFindByName = `-- name: ProjectSecretFindByName :one
SELECT id, project_id, name, value, organisation_id, created_at, updated_at, deleted_at FROM project_secrets WHERE project_id = $1 AND name = $2
`

type ProjectSecretFindByNameParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	Name      string      `json:"name"`
}

func (q *Queries) ProjectSecretFindByName(ctx context.Context, arg *ProjectSecretFindByNameParams) (*ProjectSecret, error) {
	row := q.db.QueryRow(ctx, projectSecretFindByName, arg.ProjectID, arg.Name)
	var i ProjectSecret
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Value,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const projectSecretFindByProject = `-- name: ProjectSecretFindByProject :many
SELECT id, project_id, name, value, organisation_id, created_at, updated_at, deleted_at FROM project_secrets WHERE project_id = $1 ORDER BY name
`

func (q *Queries) ProjectSecretFindByProject(ctx context.Context, projectID pgtype.UUID) ([]*ProjectSecret, error) {
	rows, err := q.db.Query(ctx, projectSecretFindByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ProjectSecret
	for rows.Next() {
		var i ProjectSecret
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Value,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectSecretUpdate = `-- name: ProjectSecretUpdate :one
UPDATE project_secrets SET value = $2, updated_at = NOW() WHERE id = $1 RETURNING id, project_id, name, value, organisation_id, created_at, updated_at, deleted_at
`

type ProjectSecretUpdateParams struct {
	ID    pgtype.UUID `json:"id"`
	Value string      `json:"value"`
}

func (q *Queries) ProjectSecretUpdate(ctx context.Context, arg *ProjectSecretUpdateParams) (*ProjectSecret, error) {
	row := q.db.QueryRow(ctx, projectSecretUpdate, arg.ID, arg.Value)
	var i ProjectSecret
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Value,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const projectUpdate = `-- name: ProjectUpdate :one
UPDATE projects SET name = $2, slug = $3, updated_at = NOW() WHERE id = $1 RETURNING id, name, slug, organisation_id, created_at, updated_at, deleted_at
`

type ProjectUpdateParams struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
	Slug string      `json:"slug"`
}

func (q *Queries) ProjectUpdate(ctx context.Context, arg *ProjectUpdateParams) (*Project, error) {
	row := q.db.QueryRow(ctx, projectUpdate, arg.ID, arg.Name, arg.Slug)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
