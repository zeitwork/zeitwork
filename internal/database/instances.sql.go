// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: instances.sql

package database

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const instanceCreate = `-- name: InstanceCreate :one
INSERT INTO instances (
    region_id, node_id, image_id, state, resources,
    default_port, ip_address, environment_variables
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, region_id, node_id, image_id, state, resources, default_port, ip_address, environment_variables, created_at, updated_at, deleted_at
`

type InstanceCreateParams struct {
	RegionID             pgtype.UUID     `json:"region_id"`
	NodeID               pgtype.UUID     `json:"node_id"`
	ImageID              pgtype.UUID     `json:"image_id"`
	State                string          `json:"state"`
	Resources            json.RawMessage `json:"resources"`
	DefaultPort          int32           `json:"default_port"`
	IpAddress            string          `json:"ip_address"`
	EnvironmentVariables string          `json:"environment_variables"`
}

func (q *Queries) InstanceCreate(ctx context.Context, arg *InstanceCreateParams) (*Instance, error) {
	row := q.db.QueryRow(ctx, instanceCreate,
		arg.RegionID,
		arg.NodeID,
		arg.ImageID,
		arg.State,
		arg.Resources,
		arg.DefaultPort,
		arg.IpAddress,
		arg.EnvironmentVariables,
	)
	var i Instance
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.NodeID,
		&i.ImageID,
		&i.State,
		&i.Resources,
		&i.DefaultPort,
		&i.IpAddress,
		&i.EnvironmentVariables,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const instanceDelete = `-- name: InstanceDelete :exec
DELETE FROM instances WHERE id = $1
`

func (q *Queries) InstanceDelete(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, instanceDelete, id)
	return err
}

const instanceFind = `-- name: InstanceFind :many
SELECT id, region_id, node_id, image_id, state, resources, default_port, ip_address, environment_variables, created_at, updated_at, deleted_at FROM instances ORDER BY created_at DESC
`

func (q *Queries) InstanceFind(ctx context.Context) ([]*Instance, error) {
	rows, err := q.db.Query(ctx, instanceFind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Instance
	for rows.Next() {
		var i Instance
		if err := rows.Scan(
			&i.ID,
			&i.RegionID,
			&i.NodeID,
			&i.ImageID,
			&i.State,
			&i.Resources,
			&i.DefaultPort,
			&i.IpAddress,
			&i.EnvironmentVariables,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const instanceFindByDeployment = `-- name: InstanceFindByDeployment :many
SELECT i.id, i.region_id, i.node_id, i.image_id, i.state, i.resources, i.default_port, i.ip_address, i.environment_variables, i.created_at, i.updated_at, i.deleted_at FROM instances i
JOIN deployment_instances di ON i.id = di.instance_id
WHERE di.deployment_id = $1 AND i.state = 'running'
`

func (q *Queries) InstanceFindByDeployment(ctx context.Context, deploymentID pgtype.UUID) ([]*Instance, error) {
	rows, err := q.db.Query(ctx, instanceFindByDeployment, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Instance
	for rows.Next() {
		var i Instance
		if err := rows.Scan(
			&i.ID,
			&i.RegionID,
			&i.NodeID,
			&i.ImageID,
			&i.State,
			&i.Resources,
			&i.DefaultPort,
			&i.IpAddress,
			&i.EnvironmentVariables,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const instanceFindById = `-- name: InstanceFindById :one
SELECT id, region_id, node_id, image_id, state, resources, default_port, ip_address, environment_variables, created_at, updated_at, deleted_at FROM instances WHERE id = $1
`

func (q *Queries) InstanceFindById(ctx context.Context, id pgtype.UUID) (*Instance, error) {
	row := q.db.QueryRow(ctx, instanceFindById, id)
	var i Instance
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.NodeID,
		&i.ImageID,
		&i.State,
		&i.Resources,
		&i.DefaultPort,
		&i.IpAddress,
		&i.EnvironmentVariables,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const instanceFindByImage = `-- name: InstanceFindByImage :many
SELECT id, region_id, node_id, image_id, state, resources, default_port, ip_address, environment_variables, created_at, updated_at, deleted_at FROM instances WHERE image_id = $1
`

func (q *Queries) InstanceFindByImage(ctx context.Context, imageID pgtype.UUID) ([]*Instance, error) {
	rows, err := q.db.Query(ctx, instanceFindByImage, imageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Instance
	for rows.Next() {
		var i Instance
		if err := rows.Scan(
			&i.ID,
			&i.RegionID,
			&i.NodeID,
			&i.ImageID,
			&i.State,
			&i.Resources,
			&i.DefaultPort,
			&i.IpAddress,
			&i.EnvironmentVariables,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const instanceFindByNode = `-- name: InstanceFindByNode :many
SELECT id, region_id, node_id, image_id, state, resources, default_port, ip_address, environment_variables, created_at, updated_at, deleted_at FROM instances WHERE node_id = $1
`

func (q *Queries) InstanceFindByNode(ctx context.Context, nodeID pgtype.UUID) ([]*Instance, error) {
	rows, err := q.db.Query(ctx, instanceFindByNode, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Instance
	for rows.Next() {
		var i Instance
		if err := rows.Scan(
			&i.ID,
			&i.RegionID,
			&i.NodeID,
			&i.ImageID,
			&i.State,
			&i.Resources,
			&i.DefaultPort,
			&i.IpAddress,
			&i.EnvironmentVariables,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const instanceFindByRegion = `-- name: InstanceFindByRegion :many
SELECT id, region_id, node_id, image_id, state, resources, default_port, ip_address, environment_variables, created_at, updated_at, deleted_at FROM instances WHERE region_id = $1 ORDER BY created_at DESC
`

func (q *Queries) InstanceFindByRegion(ctx context.Context, regionID pgtype.UUID) ([]*Instance, error) {
	rows, err := q.db.Query(ctx, instanceFindByRegion, regionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Instance
	for rows.Next() {
		var i Instance
		if err := rows.Scan(
			&i.ID,
			&i.RegionID,
			&i.NodeID,
			&i.ImageID,
			&i.State,
			&i.Resources,
			&i.DefaultPort,
			&i.IpAddress,
			&i.EnvironmentVariables,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const instanceFindByState = `-- name: InstanceFindByState :many
SELECT id, region_id, node_id, image_id, state, resources, default_port, ip_address, environment_variables, created_at, updated_at, deleted_at FROM instances WHERE state = $1
`

func (q *Queries) InstanceFindByState(ctx context.Context, state string) ([]*Instance, error) {
	rows, err := q.db.Query(ctx, instanceFindByState, state)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Instance
	for rows.Next() {
		var i Instance
		if err := rows.Scan(
			&i.ID,
			&i.RegionID,
			&i.NodeID,
			&i.ImageID,
			&i.State,
			&i.Resources,
			&i.DefaultPort,
			&i.IpAddress,
			&i.EnvironmentVariables,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const instanceUpdateNode = `-- name: InstanceUpdateNode :one
UPDATE instances SET node_id = $2, updated_at = NOW() WHERE id = $1 RETURNING id, region_id, node_id, image_id, state, resources, default_port, ip_address, environment_variables, created_at, updated_at, deleted_at
`

type InstanceUpdateNodeParams struct {
	ID     pgtype.UUID `json:"id"`
	NodeID pgtype.UUID `json:"node_id"`
}

func (q *Queries) InstanceUpdateNode(ctx context.Context, arg *InstanceUpdateNodeParams) (*Instance, error) {
	row := q.db.QueryRow(ctx, instanceUpdateNode, arg.ID, arg.NodeID)
	var i Instance
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.NodeID,
		&i.ImageID,
		&i.State,
		&i.Resources,
		&i.DefaultPort,
		&i.IpAddress,
		&i.EnvironmentVariables,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const instanceUpdateState = `-- name: InstanceUpdateState :one
UPDATE instances SET state = $2, updated_at = NOW() WHERE id = $1 RETURNING id, region_id, node_id, image_id, state, resources, default_port, ip_address, environment_variables, created_at, updated_at, deleted_at
`

type InstanceUpdateStateParams struct {
	ID    pgtype.UUID `json:"id"`
	State string      `json:"state"`
}

func (q *Queries) InstanceUpdateState(ctx context.Context, arg *InstanceUpdateStateParams) (*Instance, error) {
	row := q.db.QueryRow(ctx, instanceUpdateState, arg.ID, arg.State)
	var i Instance
	err := row.Scan(
		&i.ID,
		&i.RegionID,
		&i.NodeID,
		&i.ImageID,
		&i.State,
		&i.Resources,
		&i.DefaultPort,
		&i.IpAddress,
		&i.EnvironmentVariables,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
