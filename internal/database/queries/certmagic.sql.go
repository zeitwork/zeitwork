// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: certmagic.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acquireCertmagicLock = `-- name: AcquireCertmagicLock :execrows
INSERT INTO certmagic_locks (key, expires)
VALUES ($1, $2)
ON CONFLICT (key)
DO UPDATE SET expires = EXCLUDED.expires
WHERE certmagic_locks.expires < NOW()
`

type AcquireCertmagicLockParams struct {
	Key     string             `json:"key"`
	Expires pgtype.Timestamptz `json:"expires"`
}

// Attempts to acquire a lock for a key
func (q *Queries) AcquireCertmagicLock(ctx context.Context, arg AcquireCertmagicLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, acquireCertmagicLock, arg.Key, arg.Expires)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const cleanupExpiredCertmagicLocks = `-- name: CleanupExpiredCertmagicLocks :exec
DELETE FROM certmagic_locks
WHERE expires < NOW()
`

// Removes expired locks
func (q *Queries) CleanupExpiredCertmagicLocks(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredCertmagicLocks)
	return err
}

const deleteCertmagicData = `-- name: DeleteCertmagicData :execrows
DELETE FROM certmagic_data
WHERE key = $1
`

// Deletes a certmagic data entry by key
func (q *Queries) DeleteCertmagicData(ctx context.Context, key string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteCertmagicData, key)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const existsCertmagicData = `-- name: ExistsCertmagicData :one
SELECT EXISTS(SELECT 1 FROM certmagic_data WHERE key = $1)
`

// Checks if a certmagic data entry exists
func (q *Queries) ExistsCertmagicData(ctx context.Context, key string) (bool, error) {
	row := q.db.QueryRow(ctx, existsCertmagicData, key)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listCertmagicDataNonRecursive = `-- name: ListCertmagicDataNonRecursive :many
SELECT key
FROM certmagic_data
WHERE key LIKE $1 || '%'
  AND position('/' in substring(key from length($1) + 1)) = 0
ORDER BY key
`

// Lists certmagic data keys with a given prefix (non-recursive - no additional slashes)
func (q *Queries) ListCertmagicDataNonRecursive(ctx context.Context, dollar_1 pgtype.Text) ([]string, error) {
	rows, err := q.db.Query(ctx, listCertmagicDataNonRecursive, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCertmagicDataRecursive = `-- name: ListCertmagicDataRecursive :many
SELECT key
FROM certmagic_data
WHERE key LIKE $1 || '%'
ORDER BY key
`

// Lists all certmagic data keys with a given prefix (recursive)
func (q *Queries) ListCertmagicDataRecursive(ctx context.Context, dollar_1 pgtype.Text) ([]string, error) {
	rows, err := q.db.Query(ctx, listCertmagicDataRecursive, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadCertmagicData = `-- name: LoadCertmagicData :one
SELECT key, value, modified
FROM certmagic_data
WHERE key = $1
`

// Loads a certmagic data entry by key
func (q *Queries) LoadCertmagicData(ctx context.Context, key string) (CertmagicDatum, error) {
	row := q.db.QueryRow(ctx, loadCertmagicData, key)
	var i CertmagicDatum
	err := row.Scan(&i.Key, &i.Value, &i.Modified)
	return i, err
}

const releaseCertmagicLock = `-- name: ReleaseCertmagicLock :execrows
DELETE FROM certmagic_locks
WHERE key = $1
`

// Releases a lock for a key
func (q *Queries) ReleaseCertmagicLock(ctx context.Context, key string) (int64, error) {
	result, err := q.db.Exec(ctx, releaseCertmagicLock, key)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const statCertmagicData = `-- name: StatCertmagicData :one
SELECT key, value, modified
FROM certmagic_data
WHERE key = $1
`

// Returns metadata about a certmagic data entry
func (q *Queries) StatCertmagicData(ctx context.Context, key string) (CertmagicDatum, error) {
	row := q.db.QueryRow(ctx, statCertmagicData, key)
	var i CertmagicDatum
	err := row.Scan(&i.Key, &i.Value, &i.Modified)
	return i, err
}

const storeCertmagicData = `-- name: StoreCertmagicData :exec
INSERT INTO certmagic_data (key, value, modified)
VALUES ($1, $2, $3)
ON CONFLICT (key)
DO UPDATE SET
    value = EXCLUDED.value,
    modified = EXCLUDED.modified
`

type StoreCertmagicDataParams struct {
	Key      string             `json:"key"`
	Value    string             `json:"value"`
	Modified pgtype.Timestamptz `json:"modified"`
}

// Stores or updates a certmagic data entry
func (q *Queries) StoreCertmagicData(ctx context.Context, arg StoreCertmagicDataParams) error {
	_, err := q.db.Exec(ctx, storeCertmagicData, arg.Key, arg.Value, arg.Modified)
	return err
}
