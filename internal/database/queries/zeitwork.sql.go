// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: zeitwork.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const buildCreate = `-- name: BuildCreate :one
INSERT INTO builds (
    id,
    status,
    project_id,
    github_commit,
    github_branch,
    organisation_id,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
RETURNING id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at
`

type BuildCreateParams struct {
	ID             pgtype.UUID `json:"id"`
	Status         BuildStatus `json:"status"`
	ProjectID      pgtype.UUID `json:"project_id"`
	GithubCommit   string      `json:"github_commit"`
	GithubBranch   string      `json:"github_branch"`
	OrganisationID pgtype.UUID `json:"organisation_id"`
}

func (q *Queries) BuildCreate(ctx context.Context, arg BuildCreateParams) (Build, error) {
	row := q.db.QueryRow(ctx, buildCreate,
		arg.ID,
		arg.Status,
		arg.ProjectID,
		arg.GithubCommit,
		arg.GithubBranch,
		arg.OrganisationID,
	)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProjectID,
		&i.GithubCommit,
		&i.GithubBranch,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.SuccessfulAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const buildFirstPending = `-- name: BuildFirstPending :one
SELECT id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at
FROM builds WHERE status = 'pending'
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) BuildFirstPending(ctx context.Context) (Build, error) {
	row := q.db.QueryRow(ctx, buildFirstPending)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProjectID,
		&i.GithubCommit,
		&i.GithubBranch,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.SuccessfulAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const buildUpdateMarkBuilding = `-- name: BuildUpdateMarkBuilding :one
UPDATE builds
SET status = 'building'
WHERE id = $1
RETURNING id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at
`

func (q *Queries) BuildUpdateMarkBuilding(ctx context.Context, id pgtype.UUID) (Build, error) {
	row := q.db.QueryRow(ctx, buildUpdateMarkBuilding, id)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProjectID,
		&i.GithubCommit,
		&i.GithubBranch,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.SuccessfulAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deploymentFind = `-- name: DeploymentFind :many
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at
FROM deployments
`

func (q *Queries) DeploymentFind(ctx context.Context) ([]Deployment, error) {
	rows, err := q.db.Query(ctx, deploymentFind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.GithubCommit,
			&i.ProjectID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentFirstPending = `-- name: DeploymentFirstPending :one
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at
FROM deployments WHERE status = 'pending'
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) DeploymentFirstPending(ctx context.Context) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentFirstPending)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deploymentUpdateMarkBuilding = `-- name: DeploymentUpdateMarkBuilding :one
UPDATE deployments
SET build_id = $2, status = 'building'
WHERE id = $1
RETURNING id, status, github_commit, project_id, build_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at
`

type DeploymentUpdateMarkBuildingParams struct {
	ID      pgtype.UUID `json:"id"`
	BuildID pgtype.UUID `json:"build_id"`
}

func (q *Queries) DeploymentUpdateMarkBuilding(ctx context.Context, arg DeploymentUpdateMarkBuildingParams) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentUpdateMarkBuilding, arg.ID, arg.BuildID)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const domainListUnverified = `-- name: DomainListUnverified :many
SELECT id, name, project_id, deployment_id, verified_at, organisation_id, created_at, updated_at, deleted_at
FROM domains
WHERE verified_at IS NULL AND deleted_at IS NULL
`

func (q *Queries) DomainListUnverified(ctx context.Context) ([]Domain, error) {
	rows, err := q.db.Query(ctx, domainListUnverified)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Domain{}
	for rows.Next() {
		var i Domain
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ProjectID,
			&i.DeploymentID,
			&i.VerifiedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const domainMarkVerified = `-- name: DomainMarkVerified :exec
UPDATE domains
SET verified_at = NOW()
WHERE id = $1
`

func (q *Queries) DomainMarkVerified(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, domainMarkVerified, id)
	return err
}
