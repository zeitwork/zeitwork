// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: build.sql

package queries

import (
	"context"

	"github.com/zeitwork/zeitwork/internal/shared/uuid"
)

const buildClaimLease = `-- name: BuildClaimLease :one
UPDATE builds
SET processing_by = $2, processing_started_at = now()
WHERE id = $1
  AND status IN ('pending', 'building')
  AND deleted_at IS NULL
  AND (
    processing_by IS NULL
        OR processing_by = $2
        OR processing_started_at < now() - interval '30 minutes'
    )
RETURNING id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at, processing_by, processing_started_at
`

type BuildClaimLeaseParams struct {
	ID           uuid.UUID `json:"id"`
	ProcessingBy uuid.UUID `json:"processing_by"`
}

// Atomically claim a build lease for processing on a server.
// Succeeds if the build is pending/building and either unclaimed, already
// claimed by this server, or the previous lease is stale.
func (q *Queries) BuildClaimLease(ctx context.Context, arg BuildClaimLeaseParams) (Build, error) {
	row := q.db.QueryRow(ctx, buildClaimLease, arg.ID, arg.ProcessingBy)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProjectID,
		&i.GithubCommit,
		&i.GithubBranch,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.SuccessfulAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProcessingBy,
		&i.ProcessingStartedAt,
	)
	return i, err
}

const buildCreate = `-- name: BuildCreate :one
INSERT INTO builds (
    id,
    status,
    project_id,
    github_commit,
    github_branch,
    organisation_id,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
RETURNING id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at, processing_by, processing_started_at
`

type BuildCreateParams struct {
	ID             uuid.UUID   `json:"id"`
	Status         BuildStatus `json:"status"`
	ProjectID      uuid.UUID   `json:"project_id"`
	GithubCommit   string      `json:"github_commit"`
	GithubBranch   string      `json:"github_branch"`
	OrganisationID uuid.UUID   `json:"organisation_id"`
}

func (q *Queries) BuildCreate(ctx context.Context, arg BuildCreateParams) (Build, error) {
	row := q.db.QueryRow(ctx, buildCreate,
		arg.ID,
		arg.Status,
		arg.ProjectID,
		arg.GithubCommit,
		arg.GithubBranch,
		arg.OrganisationID,
	)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProjectID,
		&i.GithubCommit,
		&i.GithubBranch,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.SuccessfulAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProcessingBy,
		&i.ProcessingStartedAt,
	)
	return i, err
}

const buildFind = `-- name: BuildFind :many
SELECT id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at, processing_by, processing_started_at
FROM builds
`

func (q *Queries) BuildFind(ctx context.Context) ([]Build, error) {
	rows, err := q.db.Query(ctx, buildFind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Build{}
	for rows.Next() {
		var i Build
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.ProjectID,
			&i.GithubCommit,
			&i.GithubBranch,
			&i.ImageID,
			&i.VmID,
			&i.PendingAt,
			&i.BuildingAt,
			&i.SuccessfulAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProcessingBy,
			&i.ProcessingStartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const buildFindByVMID = `-- name: BuildFindByVMID :many
SELECT id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at, processing_by, processing_started_at FROM builds WHERE vm_id = $1
`

func (q *Queries) BuildFindByVMID(ctx context.Context, vmID uuid.UUID) ([]Build, error) {
	rows, err := q.db.Query(ctx, buildFindByVMID, vmID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Build{}
	for rows.Next() {
		var i Build
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.ProjectID,
			&i.GithubCommit,
			&i.GithubBranch,
			&i.ImageID,
			&i.VmID,
			&i.PendingAt,
			&i.BuildingAt,
			&i.SuccessfulAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProcessingBy,
			&i.ProcessingStartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const buildFindWaitingForBuildImage = `-- name: BuildFindWaitingForBuildImage :many
SELECT id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at, processing_by, processing_started_at FROM builds 
WHERE status IN ('pending', 'building') 
  AND image_id IS NULL 
  AND deleted_at IS NULL
`

func (q *Queries) BuildFindWaitingForBuildImage(ctx context.Context) ([]Build, error) {
	rows, err := q.db.Query(ctx, buildFindWaitingForBuildImage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Build{}
	for rows.Next() {
		var i Build
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.ProjectID,
			&i.GithubCommit,
			&i.GithubBranch,
			&i.ImageID,
			&i.VmID,
			&i.PendingAt,
			&i.BuildingAt,
			&i.SuccessfulAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProcessingBy,
			&i.ProcessingStartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const buildFirstByID = `-- name: BuildFirstByID :one
SELECT id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at, processing_by, processing_started_at
FROM builds
WHERE id = $1
LIMIT 1
`

func (q *Queries) BuildFirstByID(ctx context.Context, id uuid.UUID) (Build, error) {
	row := q.db.QueryRow(ctx, buildFirstByID, id)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProjectID,
		&i.GithubCommit,
		&i.GithubBranch,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.SuccessfulAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProcessingBy,
		&i.ProcessingStartedAt,
	)
	return i, err
}

const buildFirstPending = `-- name: BuildFirstPending :one
SELECT id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at, processing_by, processing_started_at
FROM builds WHERE status = 'pending'
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) BuildFirstPending(ctx context.Context) (Build, error) {
	row := q.db.QueryRow(ctx, buildFirstPending)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProjectID,
		&i.GithubCommit,
		&i.GithubBranch,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.SuccessfulAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProcessingBy,
		&i.ProcessingStartedAt,
	)
	return i, err
}

const buildLogCreate = `-- name: BuildLogCreate :exec
INSERT INTO build_logs (id, build_id, message, level, organisation_id, created_at)
VALUES ($1, $2, $3, $4, $5, NOW())
`

type BuildLogCreateParams struct {
	ID             uuid.UUID `json:"id"`
	BuildID        uuid.UUID `json:"build_id"`
	Message        string    `json:"message"`
	Level          string    `json:"level"`
	OrganisationID uuid.UUID `json:"organisation_id"`
}

func (q *Queries) BuildLogCreate(ctx context.Context, arg BuildLogCreateParams) error {
	_, err := q.db.Exec(ctx, buildLogCreate,
		arg.ID,
		arg.BuildID,
		arg.Message,
		arg.Level,
		arg.OrganisationID,
	)
	return err
}

const buildMarkBuilding = `-- name: BuildMarkBuilding :exec
UPDATE builds
SET status = 'building', building_at = now(), vm_id = $2
WHERE id = $1
`

type BuildMarkBuildingParams struct {
	ID   uuid.UUID `json:"id"`
	VmID uuid.UUID `json:"vm_id"`
}

func (q *Queries) BuildMarkBuilding(ctx context.Context, arg BuildMarkBuildingParams) error {
	_, err := q.db.Exec(ctx, buildMarkBuilding, arg.ID, arg.VmID)
	return err
}

const buildMarkFailed = `-- name: BuildMarkFailed :exec
UPDATE builds
SET status = 'failed', failed_at = now()
WHERE id = $1
`

func (q *Queries) BuildMarkFailed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, buildMarkFailed, id)
	return err
}

const buildMarkSuccessful = `-- name: BuildMarkSuccessful :exec
UPDATE builds
SET status = 'succesful', successful_at = now(), image_id = $2
WHERE id = $1
`

type BuildMarkSuccessfulParams struct {
	ID      uuid.UUID `json:"id"`
	ImageID uuid.UUID `json:"image_id"`
}

func (q *Queries) BuildMarkSuccessful(ctx context.Context, arg BuildMarkSuccessfulParams) error {
	_, err := q.db.Exec(ctx, buildMarkSuccessful, arg.ID, arg.ImageID)
	return err
}

const buildReleaseLease = `-- name: BuildReleaseLease :exec
UPDATE builds
SET processing_by = NULL, processing_started_at = NULL
WHERE id = $1
  AND processing_by = $2
`

type BuildReleaseLeaseParams struct {
	ID           uuid.UUID `json:"id"`
	ProcessingBy uuid.UUID `json:"processing_by"`
}

// Release a build processing lease if it's still owned by this server.
func (q *Queries) BuildReleaseLease(ctx context.Context, arg BuildReleaseLeaseParams) error {
	_, err := q.db.Exec(ctx, buildReleaseLease, arg.ID, arg.ProcessingBy)
	return err
}
