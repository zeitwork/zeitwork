// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: build.sql

package queries

import (
	"context"

	"github.com/google/uuid"
)

const buildCreate = `-- name: BuildCreate :one
INSERT INTO builds (
    id,
    status,
    project_id,
    github_commit,
    github_branch,
    organisation_id,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
RETURNING id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at
`

type BuildCreateParams struct {
	ID             uuid.UUID   `json:"id"`
	Status         BuildStatus `json:"status"`
	ProjectID      uuid.UUID   `json:"project_id"`
	GithubCommit   string      `json:"github_commit"`
	GithubBranch   string      `json:"github_branch"`
	OrganisationID uuid.UUID   `json:"organisation_id"`
}

func (q *Queries) BuildCreate(ctx context.Context, arg BuildCreateParams) (Build, error) {
	row := q.db.QueryRow(ctx, buildCreate,
		arg.ID,
		arg.Status,
		arg.ProjectID,
		arg.GithubCommit,
		arg.GithubBranch,
		arg.OrganisationID,
	)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProjectID,
		&i.GithubCommit,
		&i.GithubBranch,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.SuccessfulAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const buildFind = `-- name: BuildFind :many
SELECT id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at
FROM builds
`

func (q *Queries) BuildFind(ctx context.Context) ([]Build, error) {
	rows, err := q.db.Query(ctx, buildFind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Build{}
	for rows.Next() {
		var i Build
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.ProjectID,
			&i.GithubCommit,
			&i.GithubBranch,
			&i.ImageID,
			&i.VmID,
			&i.PendingAt,
			&i.BuildingAt,
			&i.SuccessfulAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const buildFirstByID = `-- name: BuildFirstByID :one
SELECT id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at
FROM builds
WHERE id = $1
LIMIT 1
`

func (q *Queries) BuildFirstByID(ctx context.Context, id uuid.UUID) (Build, error) {
	row := q.db.QueryRow(ctx, buildFirstByID, id)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProjectID,
		&i.GithubCommit,
		&i.GithubBranch,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.SuccessfulAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const buildFirstPending = `-- name: BuildFirstPending :one
SELECT id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at
FROM builds WHERE status = 'pending'
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) BuildFirstPending(ctx context.Context) (Build, error) {
	row := q.db.QueryRow(ctx, buildFirstPending)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProjectID,
		&i.GithubCommit,
		&i.GithubBranch,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.SuccessfulAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const buildUpdateMarkBuilding = `-- name: BuildUpdateMarkBuilding :one
UPDATE builds
SET status = 'building'
WHERE id = $1
RETURNING id, status, project_id, github_commit, github_branch, image_id, vm_id, pending_at, building_at, successful_at, failed_at, organisation_id, created_at, updated_at, deleted_at
`

func (q *Queries) BuildUpdateMarkBuilding(ctx context.Context, id uuid.UUID) (Build, error) {
	row := q.db.QueryRow(ctx, buildUpdateMarkBuilding, id)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProjectID,
		&i.GithubCommit,
		&i.GithubBranch,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.SuccessfulAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
