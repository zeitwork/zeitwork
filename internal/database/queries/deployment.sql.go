// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: deployment.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/zeitwork/zeitwork/internal/shared/uuid"
)

const deploymentFind = `-- name: DeploymentFind :many
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at
FROM deployments
`

func (q *Queries) DeploymentFind(ctx context.Context) ([]Deployment, error) {
	rows, err := q.db.Query(ctx, deploymentFind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.GithubCommit,
			&i.ProjectID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.PendingAt,
			&i.BuildingAt,
			&i.StartingAt,
			&i.RunningAt,
			&i.StoppingAt,
			&i.StoppedAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentFindByBuildID = `-- name: DeploymentFindByBuildID :many
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at FROM deployments WHERE build_id = $1
`

func (q *Queries) DeploymentFindByBuildID(ctx context.Context, buildID uuid.UUID) ([]Deployment, error) {
	rows, err := q.db.Query(ctx, deploymentFindByBuildID, buildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.GithubCommit,
			&i.ProjectID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.PendingAt,
			&i.BuildingAt,
			&i.StartingAt,
			&i.RunningAt,
			&i.StoppingAt,
			&i.StoppedAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentFindByVMID = `-- name: DeploymentFindByVMID :one
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at FROM deployments WHERE vm_id = $1 LIMIT 1
`

func (q *Queries) DeploymentFindByVMID(ctx context.Context, vmID uuid.UUID) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentFindByVMID, vmID)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.StartingAt,
		&i.RunningAt,
		&i.StoppingAt,
		&i.StoppedAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deploymentFindNewest = `-- name: DeploymentFindNewest :one
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at 
FROM deployments 
WHERE project_id = $1 
ORDER BY id DESC 
LIMIT 1
`

func (q *Queries) DeploymentFindNewest(ctx context.Context, projectID uuid.UUID) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentFindNewest, projectID)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.StartingAt,
		&i.RunningAt,
		&i.StoppingAt,
		&i.StoppedAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deploymentFindRunningAndOlder = `-- name: DeploymentFindRunningAndOlder :many
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at FROM deployments
WHERE project_id = $1
  AND id < $2
  AND running_at IS NOT NULL
  AND deleted_at IS NULL
`

type DeploymentFindRunningAndOlderParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	ID        uuid.UUID `json:"id"`
}

// Find all running deployments for a project, older than the specified deployment
func (q *Queries) DeploymentFindRunningAndOlder(ctx context.Context, arg DeploymentFindRunningAndOlderParams) ([]Deployment, error) {
	rows, err := q.db.Query(ctx, deploymentFindRunningAndOlder, arg.ProjectID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.GithubCommit,
			&i.ProjectID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.PendingAt,
			&i.BuildingAt,
			&i.StartingAt,
			&i.RunningAt,
			&i.StoppingAt,
			&i.StoppedAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentFindRunningByServerID = `-- name: DeploymentFindRunningByServerID :many
SELECT d.id, d.status, d.github_commit, d.project_id, d.build_id, d.image_id, d.vm_id, d.pending_at, d.building_at, d.starting_at, d.running_at, d.stopping_at, d.stopped_at, d.failed_at, d.organisation_id, d.created_at, d.updated_at, d.deleted_at FROM deployments d
INNER JOIN vms v ON d.vm_id = v.id
WHERE v.server_id = $1
  AND d.status = 'running'
  AND d.deleted_at IS NULL
`

// Find all running deployments whose VM is on a specific server.
func (q *Queries) DeploymentFindRunningByServerID(ctx context.Context, serverID uuid.UUID) ([]Deployment, error) {
	rows, err := q.db.Query(ctx, deploymentFindRunningByServerID, serverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.GithubCommit,
			&i.ProjectID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.PendingAt,
			&i.BuildingAt,
			&i.StartingAt,
			&i.RunningAt,
			&i.StoppingAt,
			&i.StoppedAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentFirstByID = `-- name: DeploymentFirstByID :one
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at
FROM deployments
WHERE id = $1
LIMIT 1
`

func (q *Queries) DeploymentFirstByID(ctx context.Context, id uuid.UUID) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentFirstByID, id)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.StartingAt,
		&i.RunningAt,
		&i.StoppingAt,
		&i.StoppedAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deploymentFirstPending = `-- name: DeploymentFirstPending :one
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at
FROM deployments WHERE status = 'pending'
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) DeploymentFirstPending(ctx context.Context) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentFirstPending)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.StartingAt,
		&i.RunningAt,
		&i.StoppingAt,
		&i.StoppedAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deploymentMarkRunning = `-- name: DeploymentMarkRunning :exec
UPDATE deployments
SET running_at = COALESCE(running_at, now()), updated_at = now()
WHERE id = $1
`

func (q *Queries) DeploymentMarkRunning(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deploymentMarkRunning, id)
	return err
}

const deploymentMarkStopped = `-- name: DeploymentMarkStopped :exec
UPDATE deployments
SET stopped_at = COALESCE(stopped_at, now()), updated_at = now()
WHERE id = $1
`

func (q *Queries) DeploymentMarkStopped(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deploymentMarkStopped, id)
	return err
}

const deploymentUpdateBuild = `-- name: DeploymentUpdateBuild :one
UPDATE deployments
SET build_id = $2, updated_at = now()
WHERE id = $1
RETURNING id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at
`

type DeploymentUpdateBuildParams struct {
	ID      uuid.UUID `json:"id"`
	BuildID uuid.UUID `json:"build_id"`
}

func (q *Queries) DeploymentUpdateBuild(ctx context.Context, arg DeploymentUpdateBuildParams) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentUpdateBuild, arg.ID, arg.BuildID)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.StartingAt,
		&i.RunningAt,
		&i.StoppingAt,
		&i.StoppedAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deploymentUpdateFailedAt = `-- name: DeploymentUpdateFailedAt :exec
UPDATE deployments
SET failed_at = COALESCE(failed_at, now()), updated_at = now()
WHERE id = $1
`

func (q *Queries) DeploymentUpdateFailedAt(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deploymentUpdateFailedAt, id)
	return err
}

const deploymentUpdateImage = `-- name: DeploymentUpdateImage :one
UPDATE deployments
SET image_id = $2, updated_at = now()
WHERE id = $1
RETURNING id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at
`

type DeploymentUpdateImageParams struct {
	ID      uuid.UUID `json:"id"`
	ImageID uuid.UUID `json:"image_id"`
}

func (q *Queries) DeploymentUpdateImage(ctx context.Context, arg DeploymentUpdateImageParams) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentUpdateImage, arg.ID, arg.ImageID)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.StartingAt,
		&i.RunningAt,
		&i.StoppingAt,
		&i.StoppedAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deploymentUpdateVM = `-- name: DeploymentUpdateVM :one
UPDATE deployments
SET vm_id = $2, updated_at = now()
WHERE id = $1
RETURNING id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at
`

type DeploymentUpdateVMParams struct {
	ID   uuid.UUID `json:"id"`
	VmID uuid.UUID `json:"vm_id"`
}

func (q *Queries) DeploymentUpdateVM(ctx context.Context, arg DeploymentUpdateVMParams) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentUpdateVM, arg.ID, arg.VmID)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.StartingAt,
		&i.RunningAt,
		&i.StoppingAt,
		&i.StoppedAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const vMLogCreate = `-- name: VMLogCreate :exec
INSERT INTO vm_logs (id, vm_id, message, level, created_at)
VALUES ($1, $2, $3, $4, NOW())
`

type VMLogCreateParams struct {
	ID      uuid.UUID   `json:"id"`
	VmID    uuid.UUID   `json:"vm_id"`
	Message string      `json:"message"`
	Level   pgtype.Text `json:"level"`
}

func (q *Queries) VMLogCreate(ctx context.Context, arg VMLogCreateParams) error {
	_, err := q.db.Exec(ctx, vMLogCreate,
		arg.ID,
		arg.VmID,
		arg.Message,
		arg.Level,
	)
	return err
}
