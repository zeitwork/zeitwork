// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: deployment.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deploymentFind = `-- name: DeploymentFind :many
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at
FROM deployments
`

func (q *Queries) DeploymentFind(ctx context.Context) ([]Deployment, error) {
	rows, err := q.db.Query(ctx, deploymentFind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.GithubCommit,
			&i.ProjectID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.PendingAt,
			&i.BuildingAt,
			&i.StartingAt,
			&i.RunningAt,
			&i.StoppingAt,
			&i.StoppedAt,
			&i.FailedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentFirstByID = `-- name: DeploymentFirstByID :one
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at
FROM deployments
WHERE id = $1
LIMIT 1
`

func (q *Queries) DeploymentFirstByID(ctx context.Context, id uuid.UUID) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentFirstByID, id)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PendingAt,
		&i.BuildingAt,
		&i.StartingAt,
		&i.RunningAt,
		&i.StoppingAt,
		&i.StoppedAt,
		&i.FailedAt,
	)
	return i, err
}

const deploymentFirstPending = `-- name: DeploymentFirstPending :one
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at
FROM deployments WHERE status = 'pending'
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) DeploymentFirstPending(ctx context.Context) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentFirstPending)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PendingAt,
		&i.BuildingAt,
		&i.StartingAt,
		&i.RunningAt,
		&i.StoppingAt,
		&i.StoppedAt,
		&i.FailedAt,
	)
	return i, err
}

const deploymentUpdateMarkBuilding = `-- name: DeploymentUpdateMarkBuilding :one
UPDATE deployments
SET build_id = $2, status = 'building'
WHERE id = $1
RETURNING id, status, github_commit, project_id, build_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at
`

type DeploymentUpdateMarkBuildingParams struct {
	ID      uuid.UUID   `json:"id"`
	BuildID pgtype.UUID `json:"build_id"`
}

func (q *Queries) DeploymentUpdateMarkBuilding(ctx context.Context, arg DeploymentUpdateMarkBuildingParams) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentUpdateMarkBuilding, arg.ID, arg.BuildID)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PendingAt,
		&i.BuildingAt,
		&i.StartingAt,
		&i.RunningAt,
		&i.StoppingAt,
		&i.StoppedAt,
		&i.FailedAt,
	)
	return i, err
}
