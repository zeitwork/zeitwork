// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: deployment.sql

package queries

import (
	"context"

	"github.com/zeitwork/zeitwork/internal/shared/uuid"
)

const deploymentFind = `-- name: DeploymentFind :many
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at
FROM deployments
`

func (q *Queries) DeploymentFind(ctx context.Context) ([]Deployment, error) {
	rows, err := q.db.Query(ctx, deploymentFind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.GithubCommit,
			&i.ProjectID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.PendingAt,
			&i.BuildingAt,
			&i.StartingAt,
			&i.RunningAt,
			&i.StoppingAt,
			&i.StoppedAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentFindByBuildID = `-- name: DeploymentFindByBuildID :many
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at FROM deployments WHERE build_id = $1
`

func (q *Queries) DeploymentFindByBuildID(ctx context.Context, buildID uuid.UUID) ([]Deployment, error) {
	rows, err := q.db.Query(ctx, deploymentFindByBuildID, buildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.GithubCommit,
			&i.ProjectID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.PendingAt,
			&i.BuildingAt,
			&i.StartingAt,
			&i.RunningAt,
			&i.StoppingAt,
			&i.StoppedAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentFindByVMID = `-- name: DeploymentFindByVMID :many
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at FROM deployments WHERE vm_id = $1
`

func (q *Queries) DeploymentFindByVMID(ctx context.Context, vmID uuid.UUID) ([]Deployment, error) {
	rows, err := q.db.Query(ctx, deploymentFindByVMID, vmID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.GithubCommit,
			&i.ProjectID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.PendingAt,
			&i.BuildingAt,
			&i.StartingAt,
			&i.RunningAt,
			&i.StoppingAt,
			&i.StoppedAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentFindOtherRunningByProjectID = `-- name: DeploymentFindOtherRunningByProjectID :many
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at FROM deployments
WHERE project_id = $1
  AND id != $2
  AND status = 'running'
  AND deleted_at IS NULL
`

type DeploymentFindOtherRunningByProjectIDParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	ID        uuid.UUID `json:"id"`
}

// Find all running deployments for a project, excluding a specific deployment
func (q *Queries) DeploymentFindOtherRunningByProjectID(ctx context.Context, arg DeploymentFindOtherRunningByProjectIDParams) ([]Deployment, error) {
	rows, err := q.db.Query(ctx, deploymentFindOtherRunningByProjectID, arg.ProjectID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.GithubCommit,
			&i.ProjectID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.PendingAt,
			&i.BuildingAt,
			&i.StartingAt,
			&i.RunningAt,
			&i.StoppingAt,
			&i.StoppedAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentFindRunningByServerID = `-- name: DeploymentFindRunningByServerID :many
SELECT d.id, d.status, d.github_commit, d.project_id, d.build_id, d.image_id, d.vm_id, d.pending_at, d.building_at, d.starting_at, d.running_at, d.stopping_at, d.stopped_at, d.failed_at, d.organisation_id, d.created_at, d.updated_at, d.deleted_at FROM deployments d
INNER JOIN vms v ON d.vm_id = v.id
WHERE v.server_id = $1
  AND d.status = 'running'
  AND d.deleted_at IS NULL
`

// Find all running deployments whose VM is on a specific server.
func (q *Queries) DeploymentFindRunningByServerID(ctx context.Context, serverID uuid.UUID) ([]Deployment, error) {
	rows, err := q.db.Query(ctx, deploymentFindRunningByServerID, serverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deployment{}
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.GithubCommit,
			&i.ProjectID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.PendingAt,
			&i.BuildingAt,
			&i.StartingAt,
			&i.RunningAt,
			&i.StoppingAt,
			&i.StoppedAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentFirstByID = `-- name: DeploymentFirstByID :one
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at
FROM deployments
WHERE id = $1
LIMIT 1
`

func (q *Queries) DeploymentFirstByID(ctx context.Context, id uuid.UUID) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentFirstByID, id)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.StartingAt,
		&i.RunningAt,
		&i.StoppingAt,
		&i.StoppedAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deploymentFirstPending = `-- name: DeploymentFirstPending :one
SELECT id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at
FROM deployments WHERE status = 'pending'
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) DeploymentFirstPending(ctx context.Context) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentFirstPending)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.StartingAt,
		&i.RunningAt,
		&i.StoppingAt,
		&i.StoppedAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deploymentMarkBuilding = `-- name: DeploymentMarkBuilding :one
UPDATE deployments
SET build_id = $2, status = 'building', building_at = now()
WHERE id = $1
RETURNING id, status, github_commit, project_id, build_id, image_id, vm_id, pending_at, building_at, starting_at, running_at, stopping_at, stopped_at, failed_at, organisation_id, created_at, updated_at, deleted_at
`

type DeploymentMarkBuildingParams struct {
	ID      uuid.UUID `json:"id"`
	BuildID uuid.UUID `json:"build_id"`
}

func (q *Queries) DeploymentMarkBuilding(ctx context.Context, arg DeploymentMarkBuildingParams) (Deployment, error) {
	row := q.db.QueryRow(ctx, deploymentMarkBuilding, arg.ID, arg.BuildID)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubCommit,
		&i.ProjectID,
		&i.BuildID,
		&i.ImageID,
		&i.VmID,
		&i.PendingAt,
		&i.BuildingAt,
		&i.StartingAt,
		&i.RunningAt,
		&i.StoppingAt,
		&i.StoppedAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deploymentMarkFailed = `-- name: DeploymentMarkFailed :exec
UPDATE deployments
SET status = 'failed', failed_at = now()
WHERE id = $1
`

func (q *Queries) DeploymentMarkFailed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deploymentMarkFailed, id)
	return err
}

const deploymentMarkRunning = `-- name: DeploymentMarkRunning :exec
UPDATE deployments
SET status = 'running', running_at = now()
WHERE id = $1
`

func (q *Queries) DeploymentMarkRunning(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deploymentMarkRunning, id)
	return err
}

const deploymentMarkStarting = `-- name: DeploymentMarkStarting :exec
UPDATE deployments
SET status = 'starting', starting_at = now(), image_id = $2
WHERE id = $1
`

type DeploymentMarkStartingParams struct {
	ID      uuid.UUID `json:"id"`
	ImageID uuid.UUID `json:"image_id"`
}

func (q *Queries) DeploymentMarkStarting(ctx context.Context, arg DeploymentMarkStartingParams) error {
	_, err := q.db.Exec(ctx, deploymentMarkStarting, arg.ID, arg.ImageID)
	return err
}

const deploymentMarkStopped = `-- name: DeploymentMarkStopped :exec
UPDATE deployments
SET status = 'stopped', stopped_at = now()
WHERE id = $1
`

func (q *Queries) DeploymentMarkStopped(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deploymentMarkStopped, id)
	return err
}

const deploymentUpdateVMID = `-- name: DeploymentUpdateVMID :exec
UPDATE deployments
SET vm_id = $2
WHERE id = $1
`

type DeploymentUpdateVMIDParams struct {
	ID   uuid.UUID `json:"id"`
	VmID uuid.UUID `json:"vm_id"`
}

func (q *Queries) DeploymentUpdateVMID(ctx context.Context, arg DeploymentUpdateVMIDParams) error {
	_, err := q.db.Exec(ctx, deploymentUpdateVMID, arg.ID, arg.VmID)
	return err
}
