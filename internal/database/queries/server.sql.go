// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: server.sql

package queries

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/zeitwork/zeitwork/internal/shared/uuid"
)

const serverAllocateIPRange = `-- name: ServerAllocateIPRange :one
WITH lock AS (
    SELECT pg_advisory_xact_lock(hashtext('server_ip_range_allocation'))
)
SELECT COALESCE(
    (SELECT host(
                set_masklen(
                    (ip_range + (1 << (32 - masklen(ip_range))))::inet,
                    20
                )
            )::cidr
     FROM servers
     WHERE deleted_at IS NULL
     ORDER BY ip_range DESC
     LIMIT 1),
    '10.1.0.0/20'::cidr
)::cidr AS next_range
FROM lock
`

// Allocate the next available /20 IP range for a new server.
// First server gets 10.1.0.0/20, second gets 10.1.16.0/20, etc.
// Each /20 contains 4096 addresses (2048 VMs with /31 pairs).
func (q *Queries) ServerAllocateIPRange(ctx context.Context) (netip.Prefix, error) {
	row := q.db.QueryRow(ctx, serverAllocateIPRange)
	var next_range netip.Prefix
	err := row.Scan(&next_range)
	return next_range, err
}

const serverFindActive = `-- name: ServerFindActive :many
SELECT id, hostname, internal_ip, ip_range, status, last_heartbeat_at, created_at, updated_at, deleted_at FROM servers
WHERE status = 'active'
  AND last_heartbeat_at > now() - interval '30 seconds'
  AND deleted_at IS NULL
`

// Find all servers that are active and have heartbeated recently (within 30s).
func (q *Queries) ServerFindActive(ctx context.Context) ([]Server, error) {
	rows, err := q.db.Query(ctx, serverFindActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Server{}
	for rows.Next() {
		var i Server
		if err := rows.Scan(
			&i.ID,
			&i.Hostname,
			&i.InternalIp,
			&i.IpRange,
			&i.Status,
			&i.LastHeartbeatAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const serverFindByID = `-- name: ServerFindByID :one
SELECT id, hostname, internal_ip, ip_range, status, last_heartbeat_at, created_at, updated_at, deleted_at FROM servers WHERE id = $1 LIMIT 1
`

func (q *Queries) ServerFindByID(ctx context.Context, id uuid.UUID) (Server, error) {
	row := q.db.QueryRow(ctx, serverFindByID, id)
	var i Server
	err := row.Scan(
		&i.ID,
		&i.Hostname,
		&i.InternalIp,
		&i.IpRange,
		&i.Status,
		&i.LastHeartbeatAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const serverFindDead = `-- name: ServerFindDead :many
SELECT id, hostname, internal_ip, ip_range, status, last_heartbeat_at, created_at, updated_at, deleted_at FROM servers
WHERE status = 'active'
  AND last_heartbeat_at < now() - interval '60 seconds'
  AND deleted_at IS NULL
`

// Find servers whose heartbeat has expired (no heartbeat for 60s).
// Used by the failover detector to identify dead servers.
func (q *Queries) ServerFindDead(ctx context.Context) ([]Server, error) {
	rows, err := q.db.Query(ctx, serverFindDead)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Server{}
	for rows.Next() {
		var i Server
		if err := rows.Scan(
			&i.ID,
			&i.Hostname,
			&i.InternalIp,
			&i.IpRange,
			&i.Status,
			&i.LastHeartbeatAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const serverFindLeastLoaded = `-- name: ServerFindLeastLoaded :one
SELECT s.id, s.hostname, s.internal_ip, s.ip_range, s.status, s.last_heartbeat_at, s.created_at, s.updated_at, s.deleted_at, COUNT(v.id) as vm_count
FROM servers s
LEFT JOIN vms v ON v.server_id = s.id
    AND v.deleted_at IS NULL
    AND v.status NOT IN ('stopped', 'failed')
WHERE s.status = 'active'
  AND s.last_heartbeat_at > now() - interval '30 seconds'
  AND s.deleted_at IS NULL
GROUP BY s.id
ORDER BY vm_count ASC
LIMIT 1
`

type ServerFindLeastLoadedRow struct {
	ID              uuid.UUID          `json:"id"`
	Hostname        string             `json:"hostname"`
	InternalIp      string             `json:"internal_ip"`
	IpRange         netip.Prefix       `json:"ip_range"`
	Status          ServerStatus       `json:"status"`
	LastHeartbeatAt pgtype.Timestamptz `json:"last_heartbeat_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	VmCount         int64              `json:"vm_count"`
}

// Pick the active server with the fewest non-deleted, non-terminal VMs.
// Used for placement decisions when creating new VMs.
func (q *Queries) ServerFindLeastLoaded(ctx context.Context) (ServerFindLeastLoadedRow, error) {
	row := q.db.QueryRow(ctx, serverFindLeastLoaded)
	var i ServerFindLeastLoadedRow
	err := row.Scan(
		&i.ID,
		&i.Hostname,
		&i.InternalIp,
		&i.IpRange,
		&i.Status,
		&i.LastHeartbeatAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.VmCount,
	)
	return i, err
}

const serverHeartbeat = `-- name: ServerHeartbeat :exec
UPDATE servers SET last_heartbeat_at = now() WHERE id = $1
`

// Update the heartbeat timestamp for a server.
func (q *Queries) ServerHeartbeat(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, serverHeartbeat, id)
	return err
}

const serverRegister = `-- name: ServerRegister :one
INSERT INTO servers (id, hostname, internal_ip, ip_range, status, last_heartbeat_at)
VALUES ($1, $2, $3, $4, 'active', now())
ON CONFLICT (id) DO UPDATE SET
    hostname = EXCLUDED.hostname,
    internal_ip = EXCLUDED.internal_ip,
    status = 'active',
    last_heartbeat_at = now(),
    updated_at = now()
RETURNING id, hostname, internal_ip, ip_range, status, last_heartbeat_at, created_at, updated_at, deleted_at
`

type ServerRegisterParams struct {
	ID         uuid.UUID    `json:"id"`
	Hostname   string       `json:"hostname"`
	InternalIp string       `json:"internal_ip"`
	IpRange    netip.Prefix `json:"ip_range"`
}

// Upsert a server record. On startup, a server registers itself.
// If it already exists (e.g., after restart), update heartbeat and status.
func (q *Queries) ServerRegister(ctx context.Context, arg ServerRegisterParams) (Server, error) {
	row := q.db.QueryRow(ctx, serverRegister,
		arg.ID,
		arg.Hostname,
		arg.InternalIp,
		arg.IpRange,
	)
	var i Server
	err := row.Scan(
		&i.ID,
		&i.Hostname,
		&i.InternalIp,
		&i.IpRange,
		&i.Status,
		&i.LastHeartbeatAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const serverSetDrained = `-- name: ServerSetDrained :exec
UPDATE servers SET status = 'drained', updated_at = now() WHERE id = $1
`

// Mark a server as drained. All VMs have been migrated off.
func (q *Queries) ServerSetDrained(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, serverSetDrained, id)
	return err
}

const serverUpdateStatus = `-- name: ServerUpdateStatus :exec
UPDATE servers SET status = $2, updated_at = now() WHERE id = $1
`

type ServerUpdateStatusParams struct {
	ID     uuid.UUID    `json:"id"`
	Status ServerStatus `json:"status"`
}

func (q *Queries) ServerUpdateStatus(ctx context.Context, arg ServerUpdateStatusParams) error {
	_, err := q.db.Exec(ctx, serverUpdateStatus, arg.ID, arg.Status)
	return err
}

const tryAdvisoryLock = `-- name: TryAdvisoryLock :one
SELECT pg_try_advisory_xact_lock(hashtext($1)) as acquired
`

// Try to acquire a transaction-scoped advisory lock (non-blocking).
// Returns true if the lock was acquired, false if another session holds it.
func (q *Queries) TryAdvisoryLock(ctx context.Context, hashtext string) (bool, error) {
	row := q.db.QueryRow(ctx, tryAdvisoryLock, hashtext)
	var acquired bool
	err := row.Scan(&acquired)
	return acquired, err
}
