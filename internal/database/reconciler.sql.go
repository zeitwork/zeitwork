// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reconciler.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignVMToDeployment = `-- name: AssignVMToDeployment :exec
UPDATE vms
SET status = 'starting',
    image_id = $2,
    updated_at = NOW()
WHERE id = $1
`

type AssignVMToDeploymentParams struct {
	ID      pgtype.UUID `json:"id"`
	ImageID pgtype.UUID `json:"image_id"`
}

// Assign a VM to a deployment and update VM status
func (q *Queries) AssignVMToDeployment(ctx context.Context, arg *AssignVMToDeploymentParams) error {
	_, err := q.db.Exec(ctx, assignVMToDeployment, arg.ID, arg.ImageID)
	return err
}

const clearDeploymentVM = `-- name: ClearDeploymentVM :exec
UPDATE deployments
SET vm_id = NULL,
    updated_at = NOW()
WHERE id = $1
`

// Clear VM assignment from deployment
func (q *Queries) ClearDeploymentVM(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearDeploymentVM, id)
	return err
}

const clearVMContainer = `-- name: ClearVMContainer :exec
UPDATE vms
SET container_name = NULL,
    image_id = NULL,
    updated_at = NOW()
WHERE id = $1
`

// Clear container and image from VM
func (q *Queries) ClearVMContainer(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearVMContainer, id)
	return err
}

const createBuild = `-- name: CreateBuild :one
INSERT INTO builds (
    id,
    status,
    project_id,
    organisation_id,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, $4, NOW(), NOW())
RETURNING id, status, project_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at
`

type CreateBuildParams struct {
	ID             pgtype.UUID   `json:"id"`
	Status         BuildStatuses `json:"status"`
	ProjectID      pgtype.UUID   `json:"project_id"`
	OrganisationID pgtype.UUID   `json:"organisation_id"`
}

// Create a new build for a deployment
func (q *Queries) CreateBuild(ctx context.Context, arg *CreateBuildParams) (*Build, error) {
	row := q.db.QueryRow(ctx, createBuild,
		arg.ID,
		arg.Status,
		arg.ProjectID,
		arg.OrganisationID,
	)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ProjectID,
		&i.ImageID,
		&i.VmID,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const createVM = `-- name: CreateVM :one
INSERT INTO vms (
    id,
    no,
    status,
    private_ip,
    region_id,
    port,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
RETURNING id, no, status, private_ip, region_id, image_id, port, server_name, container_name, created_at, updated_at, deleted_at
`

type CreateVMParams struct {
	ID        pgtype.UUID `json:"id"`
	No        int32       `json:"no"`
	Status    interface{} `json:"status"`
	PrivateIp string      `json:"private_ip"`
	RegionID  pgtype.UUID `json:"region_id"`
	Port      int32       `json:"port"`
}

// Create a new VM
func (q *Queries) CreateVM(ctx context.Context, arg *CreateVMParams) (*Vm, error) {
	row := q.db.QueryRow(ctx, createVM,
		arg.ID,
		arg.No,
		arg.Status,
		arg.PrivateIp,
		arg.RegionID,
		arg.Port,
	)
	var i Vm
	err := row.Scan(
		&i.ID,
		&i.No,
		&i.Status,
		&i.PrivateIp,
		&i.RegionID,
		&i.ImageID,
		&i.Port,
		&i.ServerName,
		&i.ContainerName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getAllRegions = `-- name: GetAllRegions :many
SELECT id, no, name, load_balancer_ipv4, load_balancer_ipv6, load_balancer_no, firewall_no, network_no, created_at, updated_at, deleted_at
FROM regions
WHERE deleted_at IS NULL
ORDER BY no ASC
`

// Get all regions
func (q *Queries) GetAllRegions(ctx context.Context) ([]*Region, error) {
	rows, err := q.db.Query(ctx, getAllRegions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Region
	for rows.Next() {
		var i Region
		if err := rows.Scan(
			&i.ID,
			&i.No,
			&i.Name,
			&i.LoadBalancerIpv4,
			&i.LoadBalancerIpv6,
			&i.LoadBalancerNo,
			&i.FirewallNo,
			&i.NetworkNo,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBuildingDeploymentsWithoutImage = `-- name: GetBuildingDeploymentsWithoutImage :many
SELECT d.id, d.status, d.deployment_id, d.github_commit, d.project_id, d.environment_id, d.build_id, d.image_id, d.vm_id, d.organisation_id, d.created_at, d.updated_at, d.deleted_at, b.status as build_status, b.image_id as build_image_id
FROM deployments d
INNER JOIN builds b ON d.build_id = b.id
WHERE d.status = 'building'
  AND d.image_id IS NULL
  AND d.deleted_at IS NULL
  AND b.deleted_at IS NULL
ORDER BY d.created_at ASC
`

type GetBuildingDeploymentsWithoutImageRow struct {
	ID             pgtype.UUID        `json:"id"`
	Status         DeploymentStatuses `json:"status"`
	DeploymentID   string             `json:"deployment_id"`
	GithubCommit   string             `json:"github_commit"`
	ProjectID      pgtype.UUID        `json:"project_id"`
	EnvironmentID  pgtype.UUID        `json:"environment_id"`
	BuildID        pgtype.UUID        `json:"build_id"`
	ImageID        pgtype.UUID        `json:"image_id"`
	VmID           pgtype.UUID        `json:"vm_id"`
	OrganisationID pgtype.UUID        `json:"organisation_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	BuildStatus    BuildStatuses      `json:"build_status"`
	BuildImageID   pgtype.UUID        `json:"build_image_id"`
}

// Get building deployments that have a build but no image yet
func (q *Queries) GetBuildingDeploymentsWithoutImage(ctx context.Context) ([]*GetBuildingDeploymentsWithoutImageRow, error) {
	rows, err := q.db.Query(ctx, getBuildingDeploymentsWithoutImage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetBuildingDeploymentsWithoutImageRow
	for rows.Next() {
		var i GetBuildingDeploymentsWithoutImageRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.DeploymentID,
			&i.GithubCommit,
			&i.ProjectID,
			&i.EnvironmentID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.BuildStatus,
			&i.BuildImageID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBuildingDeploymentsWithoutVM = `-- name: GetBuildingDeploymentsWithoutVM :many
SELECT id, status, deployment_id, github_commit, project_id, environment_id, build_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at
FROM deployments
WHERE status = 'building'
  AND image_id IS NOT NULL
  AND vm_id IS NULL
  AND deleted_at IS NULL
ORDER BY created_at ASC
`

// Get building deployments that have an image but no VM assigned
func (q *Queries) GetBuildingDeploymentsWithoutVM(ctx context.Context) ([]*Deployment, error) {
	rows, err := q.db.Query(ctx, getBuildingDeploymentsWithoutVM)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Deployment
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.DeploymentID,
			&i.GithubCommit,
			&i.ProjectID,
			&i.EnvironmentID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedDeployments = `-- name: GetFailedDeployments :many
SELECT id, status, deployment_id, github_commit, project_id, environment_id, build_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at
FROM deployments
WHERE status = 'failed'
  AND vm_id IS NOT NULL
  AND deleted_at IS NULL
`

// Get failed deployments that need cleanup
func (q *Queries) GetFailedDeployments(ctx context.Context) ([]*Deployment, error) {
	rows, err := q.db.Query(ctx, getFailedDeployments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Deployment
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.DeploymentID,
			&i.GithubCommit,
			&i.ProjectID,
			&i.EnvironmentID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImageByID = `-- name: GetImageByID :one
SELECT id, registry, repository, tag, digest, created_at, updated_at, deleted_at
FROM images
WHERE id = $1
  AND deleted_at IS NULL
`

// Get image details by ID
func (q *Queries) GetImageByID(ctx context.Context, id pgtype.UUID) (*Image, error) {
	row := q.db.QueryRow(ctx, getImageByID, id)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Registry,
		&i.Repository,
		&i.Tag,
		&i.Digest,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getInactiveDeployments = `-- name: GetInactiveDeployments :many
SELECT id, status, deployment_id, github_commit, project_id, environment_id, build_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at
FROM deployments
WHERE status = 'inactive'
  AND vm_id IS NOT NULL
  AND deleted_at IS NULL
`

// Get inactive deployments that need cleanup
func (q *Queries) GetInactiveDeployments(ctx context.Context) ([]*Deployment, error) {
	rows, err := q.db.Query(ctx, getInactiveDeployments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Deployment
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.DeploymentID,
			&i.GithubCommit,
			&i.ProjectID,
			&i.EnvironmentID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextVMNumber = `-- name: GetNextVMNumber :one
SELECT COALESCE(MAX(no), 0) + 1 as next_no
FROM vms
`

// Get the next available VM number
func (q *Queries) GetNextVMNumber(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, getNextVMNumber)
	var next_no int32
	err := row.Scan(&next_no)
	return next_no, err
}

const getPoolVMs = `-- name: GetPoolVMs :many

SELECT id, no, status, private_ip, region_id, image_id, port, server_name, container_name, created_at, updated_at, deleted_at
FROM vms
WHERE status = 'pooling'
  AND deleted_at IS NULL
ORDER BY created_at ASC
`

// VM QUERIES
// Get VMs that are available in the pool
func (q *Queries) GetPoolVMs(ctx context.Context) ([]*Vm, error) {
	rows, err := q.db.Query(ctx, getPoolVMs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Vm
	for rows.Next() {
		var i Vm
		if err := rows.Scan(
			&i.ID,
			&i.No,
			&i.Status,
			&i.PrivateIp,
			&i.RegionID,
			&i.ImageID,
			&i.Port,
			&i.ServerName,
			&i.ContainerName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueuedDeployments = `-- name: GetQueuedDeployments :many

SELECT id, status, deployment_id, github_commit, project_id, environment_id, build_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at
FROM deployments
WHERE status = 'queued'
  AND build_id IS NULL
  AND deleted_at IS NULL
ORDER BY created_at ASC
`

// DEPLOYMENT QUERIES
// Get deployments in queued state (no build assigned)
func (q *Queries) GetQueuedDeployments(ctx context.Context) ([]*Deployment, error) {
	rows, err := q.db.Query(ctx, getQueuedDeployments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Deployment
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.DeploymentID,
			&i.GithubCommit,
			&i.ProjectID,
			&i.EnvironmentID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadyDeployments = `-- name: GetReadyDeployments :many
SELECT id, status, deployment_id, github_commit, project_id, environment_id, build_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at
FROM deployments
WHERE status = 'ready'
  AND deleted_at IS NULL
ORDER BY project_id, environment_id, created_at DESC
`

// Get all ready deployments grouped by project+environment
func (q *Queries) GetReadyDeployments(ctx context.Context) ([]*Deployment, error) {
	rows, err := q.db.Query(ctx, getReadyDeployments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Deployment
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.DeploymentID,
			&i.GithubCommit,
			&i.ProjectID,
			&i.EnvironmentID,
			&i.BuildID,
			&i.ImageID,
			&i.VmID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimedOutBuilds = `-- name: GetTimedOutBuilds :many

SELECT id, status, project_id, image_id, vm_id, organisation_id, created_at, updated_at, deleted_at
FROM builds
WHERE status = 'building'
  AND deleted_at IS NULL
  AND updated_at < NOW() - INTERVAL '10 minutes'
ORDER BY updated_at ASC
`

// BUILD QUERIES
// Get builds that have been in "building" state for too long
func (q *Queries) GetTimedOutBuilds(ctx context.Context) ([]*Build, error) {
	rows, err := q.db.Query(ctx, getTimedOutBuilds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Build
	for rows.Next() {
		var i Build
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.ProjectID,
			&i.ImageID,
			&i.VmID,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnverifiedDomains = `-- name: GetUnverifiedDomains :many

SELECT id, name, deployment_id, verification_token, verified_at, organisation_id, created_at, updated_at, deleted_at
FROM domains
WHERE verified_at IS NULL
  AND deleted_at IS NULL
  AND updated_at > NOW() - INTERVAL '48 hours'
ORDER BY updated_at DESC
`

// DOMAIN QUERIES
// Get domains that need DNS verification (unverified and recently updated)
func (q *Queries) GetUnverifiedDomains(ctx context.Context) ([]*Domain, error) {
	rows, err := q.db.Query(ctx, getUnverifiedDomains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Domain
	for rows.Next() {
		var i Domain
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DeploymentID,
			&i.VerificationToken,
			&i.VerifiedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVMByID = `-- name: GetVMByID :one
SELECT id, no, status, private_ip, region_id, image_id, port, server_name, container_name, created_at, updated_at, deleted_at
FROM vms
WHERE id = $1
  AND deleted_at IS NULL
`

// Get a VM by ID
func (q *Queries) GetVMByID(ctx context.Context, id pgtype.UUID) (*Vm, error) {
	row := q.db.QueryRow(ctx, getVMByID, id)
	var i Vm
	err := row.Scan(
		&i.ID,
		&i.No,
		&i.Status,
		&i.PrivateIp,
		&i.RegionID,
		&i.ImageID,
		&i.Port,
		&i.ServerName,
		&i.ContainerName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getVMsByRegion = `-- name: GetVMsByRegion :many
SELECT 
    region_id,
    status,
    COUNT(*) as count
FROM vms
WHERE deleted_at IS NULL
GROUP BY region_id, status
`

type GetVMsByRegionRow struct {
	RegionID pgtype.UUID `json:"region_id"`
	Status   interface{} `json:"status"`
	Count    int64       `json:"count"`
}

// Get count of VMs by region and status
func (q *Queries) GetVMsByRegion(ctx context.Context) ([]*GetVMsByRegionRow, error) {
	rows, err := q.db.Query(ctx, getVMsByRegion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetVMsByRegionRow
	for rows.Next() {
		var i GetVMsByRegionRow
		if err := rows.Scan(&i.RegionID, &i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markBuildTimedOut = `-- name: MarkBuildTimedOut :exec
UPDATE builds
SET status = 'error',
    updated_at = NOW()
WHERE id = $1
`

// Mark a build as error due to timeout
func (q *Queries) MarkBuildTimedOut(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markBuildTimedOut, id)
	return err
}

const markDeploymentFailed = `-- name: MarkDeploymentFailed :exec
UPDATE deployments
SET status = 'failed',
    updated_at = NOW()
WHERE id = $1
`

// Mark deployment as failed
func (q *Queries) MarkDeploymentFailed(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markDeploymentFailed, id)
	return err
}

const markDeploymentInactive = `-- name: MarkDeploymentInactive :exec
UPDATE deployments
SET status = 'inactive',
    updated_at = NOW()
WHERE id = $1
`

// Mark deployment as inactive
func (q *Queries) MarkDeploymentInactive(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markDeploymentInactive, id)
	return err
}

const markDomainVerified = `-- name: MarkDomainVerified :exec
UPDATE domains
SET verified_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

// Mark a domain as verified
func (q *Queries) MarkDomainVerified(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markDomainVerified, id)
	return err
}

const markVMDeleting = `-- name: MarkVMDeleting :exec
UPDATE vms
SET status = 'deleting',
    updated_at = NOW()
WHERE id = $1
`

// Mark a VM for deletion
func (q *Queries) MarkVMDeleting(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markVMDeleting, id)
	return err
}

const markVMRunning = `-- name: MarkVMRunning :exec
UPDATE vms
SET status = 'running',
    updated_at = NOW()
WHERE id = $1
`

// Mark VM as running after container deployment
func (q *Queries) MarkVMRunning(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markVMRunning, id)
	return err
}

const returnVMToPool = `-- name: ReturnVMToPool :exec
UPDATE vms
SET status = 'pooling',
    image_id = NULL,
    updated_at = NOW()
WHERE id = $1
`

// Return a VM to the pool
func (q *Queries) ReturnVMToPool(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, returnVMToPool, id)
	return err
}

const updateDeploymentWithBuild = `-- name: UpdateDeploymentWithBuild :exec
UPDATE deployments
SET build_id = $2,
    status = 'building',
    updated_at = NOW()
WHERE id = $1
`

type UpdateDeploymentWithBuildParams struct {
	ID      pgtype.UUID `json:"id"`
	BuildID pgtype.UUID `json:"build_id"`
}

// Update deployment with build_id and change status to building
func (q *Queries) UpdateDeploymentWithBuild(ctx context.Context, arg *UpdateDeploymentWithBuildParams) error {
	_, err := q.db.Exec(ctx, updateDeploymentWithBuild, arg.ID, arg.BuildID)
	return err
}

const updateDeploymentWithImage = `-- name: UpdateDeploymentWithImage :exec
UPDATE deployments
SET image_id = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateDeploymentWithImageParams struct {
	ID      pgtype.UUID `json:"id"`
	ImageID pgtype.UUID `json:"image_id"`
}

// Update deployment with image_id
func (q *Queries) UpdateDeploymentWithImage(ctx context.Context, arg *UpdateDeploymentWithImageParams) error {
	_, err := q.db.Exec(ctx, updateDeploymentWithImage, arg.ID, arg.ImageID)
	return err
}

const updateDeploymentWithVM = `-- name: UpdateDeploymentWithVM :exec
UPDATE deployments
SET vm_id = $2,
    status = 'ready',
    updated_at = NOW()
WHERE id = $1
`

type UpdateDeploymentWithVMParams struct {
	ID   pgtype.UUID `json:"id"`
	VmID pgtype.UUID `json:"vm_id"`
}

// Update deployment with vm_id and change status to ready
func (q *Queries) UpdateDeploymentWithVM(ctx context.Context, arg *UpdateDeploymentWithVMParams) error {
	_, err := q.db.Exec(ctx, updateDeploymentWithVM, arg.ID, arg.VmID)
	return err
}

const updateVMContainerName = `-- name: UpdateVMContainerName :exec
UPDATE vms
SET container_name = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateVMContainerNameParams struct {
	ID            pgtype.UUID `json:"id"`
	ContainerName pgtype.Text `json:"container_name"`
}

// Update VM with container name after deployment
func (q *Queries) UpdateVMContainerName(ctx context.Context, arg *UpdateVMContainerNameParams) error {
	_, err := q.db.Exec(ctx, updateVMContainerName, arg.ID, arg.ContainerName)
	return err
}

const updateVMServerDetails = `-- name: UpdateVMServerDetails :exec
UPDATE vms
SET server_name = $2,
    private_ip = $3,
    updated_at = NOW()
WHERE id = $1
`

type UpdateVMServerDetailsParams struct {
	ID         pgtype.UUID `json:"id"`
	ServerName pgtype.Text `json:"server_name"`
	PrivateIp  string      `json:"private_ip"`
}

// Update VM with server name and private IP after Hetzner server creation
func (q *Queries) UpdateVMServerDetails(ctx context.Context, arg *UpdateVMServerDetailsParams) error {
	_, err := q.db.Exec(ctx, updateVMServerDetails, arg.ID, arg.ServerName, arg.PrivateIp)
	return err
}
