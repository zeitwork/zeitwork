// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ssl.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const sslCertsDelete = `-- name: SslCertsDelete :execrows
UPDATE ssl_certs
SET deleted_at = now(), updated_at = now()
WHERE "key" = $1
  AND deleted_at IS NULL
`

func (q *Queries) SslCertsDelete(ctx context.Context, key string) (int64, error) {
	result, err := q.db.Exec(ctx, sslCertsDelete, key)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const sslCertsGetById = `-- name: SslCertsGetById :one

SELECT 
    id,
    "key",
    value,
    expires_at,
    created_at,
    updated_at
FROM ssl_certs
WHERE id = $1
  AND deleted_at IS NULL
`

type SslCertsGetByIdRow struct {
	ID        pgtype.UUID        `json:"id"`
	Key       string             `json:"key"`
	Value     string             `json:"value"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// SSL certificates and locks queries for CertManager and DB-backed storage
func (q *Queries) SslCertsGetById(ctx context.Context, id pgtype.UUID) (*SslCertsGetByIdRow, error) {
	row := q.db.QueryRow(ctx, sslCertsGetById, id)
	var i SslCertsGetByIdRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const sslCertsGetByKey = `-- name: SslCertsGetByKey :one
SELECT 
    id,
    "key",
    value,
    expires_at,
    created_at,
    updated_at
FROM ssl_certs
WHERE "key" = $1
  AND deleted_at IS NULL
`

type SslCertsGetByKeyRow struct {
	ID        pgtype.UUID        `json:"id"`
	Key       string             `json:"key"`
	Value     string             `json:"value"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) SslCertsGetByKey(ctx context.Context, key string) (*SslCertsGetByKeyRow, error) {
	row := q.db.QueryRow(ctx, sslCertsGetByKey, key)
	var i SslCertsGetByKeyRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const sslCertsListPrefix = `-- name: SslCertsListPrefix :many
SELECT "key" AS key
FROM ssl_certs
WHERE "key" LIKE ($1 || '%')
  AND deleted_at IS NULL
`

func (q *Queries) SslCertsListPrefix(ctx context.Context, dollar_1 pgtype.Text) ([]string, error) {
	rows, err := q.db.Query(ctx, sslCertsListPrefix, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sslCertsStat = `-- name: SslCertsStat :one
SELECT 
    char_length(value) AS size,
    updated_at
FROM ssl_certs
WHERE "key" = $1
  AND deleted_at IS NULL
`

type SslCertsStatRow struct {
	Size      int32              `json:"size"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) SslCertsStat(ctx context.Context, key string) (*SslCertsStatRow, error) {
	row := q.db.QueryRow(ctx, sslCertsStat, key)
	var i SslCertsStatRow
	err := row.Scan(&i.Size, &i.UpdatedAt)
	return &i, err
}

const sslCertsUpsert = `-- name: SslCertsUpsert :one
INSERT INTO ssl_certs (
    id,
    "key",
    value,
    expires_at
) VALUES (
    $1,
    $2,
    $3,
    $4
)
ON CONFLICT ("key") DO UPDATE SET
    value = EXCLUDED.value,
    expires_at = EXCLUDED.expires_at,
    updated_at = now()
RETURNING 
    id,
    "key",
    value,
    expires_at,
    created_at,
    updated_at
`

type SslCertsUpsertParams struct {
	ID        pgtype.UUID        `json:"id"`
	Key       string             `json:"key"`
	Value     string             `json:"value"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

type SslCertsUpsertRow struct {
	ID        pgtype.UUID        `json:"id"`
	Key       string             `json:"key"`
	Value     string             `json:"value"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) SslCertsUpsert(ctx context.Context, arg *SslCertsUpsertParams) (*SslCertsUpsertRow, error) {
	row := q.db.QueryRow(ctx, sslCertsUpsert,
		arg.ID,
		arg.Key,
		arg.Value,
		arg.ExpiresAt,
	)
	var i SslCertsUpsertRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const sslLocksRelease = `-- name: SslLocksRelease :execrows
DELETE FROM ssl_locks
WHERE "key" = $1
`

func (q *Queries) SslLocksRelease(ctx context.Context, key string) (int64, error) {
	result, err := q.db.Exec(ctx, sslLocksRelease, key)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const sslLocksTryAcquire = `-- name: SslLocksTryAcquire :one

INSERT INTO ssl_locks (id, "key", expires_at)
VALUES ($2, $1, $3)
ON CONFLICT ("key") DO UPDATE SET
    id = EXCLUDED.id,
    expires_at = EXCLUDED.expires_at,
    updated_at = now()
WHERE ssl_locks.expires_at < now()
RETURNING id
`

type SslLocksTryAcquireParams struct {
	Key       string             `json:"key"`
	ID        pgtype.UUID        `json:"id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

// Locking helpers
func (q *Queries) SslLocksTryAcquire(ctx context.Context, arg *SslLocksTryAcquireParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, sslLocksTryAcquire, arg.Key, arg.ID, arg.ExpiresAt)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
