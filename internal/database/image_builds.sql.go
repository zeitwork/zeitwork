// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: image_builds.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const imageBuildsComplete = `-- name: ImageBuildsComplete :one
UPDATE image_builds 
SET status = 'completed', 
    completed_at = now(), 
    updated_at = now()
WHERE id = $1
RETURNING 
    id,
    status,
    deployment_id,
    started_at,
    completed_at,
    failed_at,
    organisation_id,
    created_at,
    updated_at
`

type ImageBuildsCompleteRow struct {
	ID             pgtype.UUID        `json:"id"`
	Status         string             `json:"status"`
	DeploymentID   pgtype.UUID        `json:"deployment_id"`
	StartedAt      pgtype.Timestamptz `json:"started_at"`
	CompletedAt    pgtype.Timestamptz `json:"completed_at"`
	FailedAt       pgtype.Timestamptz `json:"failed_at"`
	OrganisationID pgtype.UUID        `json:"organisation_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

// Mark an image build as completed
func (q *Queries) ImageBuildsComplete(ctx context.Context, id pgtype.UUID) (*ImageBuildsCompleteRow, error) {
	row := q.db.QueryRow(ctx, imageBuildsComplete, id)
	var i ImageBuildsCompleteRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.DeploymentID,
		&i.StartedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const imageBuildsCreate = `-- name: ImageBuildsCreate :one
INSERT INTO image_builds (
    id,
    status,
    deployment_id,
    organisation_id
) VALUES (
    $1,
    'pending',
    $2,
    $3
)
RETURNING 
    id,
    status,
    deployment_id,
    started_at,
    completed_at,
    failed_at,
    organisation_id,
    created_at,
    updated_at
`

type ImageBuildsCreateParams struct {
	ID             pgtype.UUID `json:"id"`
	DeploymentID   pgtype.UUID `json:"deployment_id"`
	OrganisationID pgtype.UUID `json:"organisation_id"`
}

type ImageBuildsCreateRow struct {
	ID             pgtype.UUID        `json:"id"`
	Status         string             `json:"status"`
	DeploymentID   pgtype.UUID        `json:"deployment_id"`
	StartedAt      pgtype.Timestamptz `json:"started_at"`
	CompletedAt    pgtype.Timestamptz `json:"completed_at"`
	FailedAt       pgtype.Timestamptz `json:"failed_at"`
	OrganisationID pgtype.UUID        `json:"organisation_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

// Create a new image build
func (q *Queries) ImageBuildsCreate(ctx context.Context, arg *ImageBuildsCreateParams) (*ImageBuildsCreateRow, error) {
	row := q.db.QueryRow(ctx, imageBuildsCreate, arg.ID, arg.DeploymentID, arg.OrganisationID)
	var i ImageBuildsCreateRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.DeploymentID,
		&i.StartedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const imageBuildsDequeuePending = `-- name: ImageBuildsDequeuePending :one
UPDATE image_builds 
SET status = 'building', 
    started_at = now(), 
    updated_at = now()
WHERE id = (
    SELECT id 
    FROM image_builds 
    WHERE status = 'pending' 
    ORDER BY created_at ASC 
    LIMIT 1
    FOR UPDATE SKIP LOCKED
)
RETURNING 
    id,
    status,
    deployment_id,
    started_at,
    completed_at,
    failed_at,
    organisation_id,
    created_at,
    updated_at
`

type ImageBuildsDequeuePendingRow struct {
	ID             pgtype.UUID        `json:"id"`
	Status         string             `json:"status"`
	DeploymentID   pgtype.UUID        `json:"deployment_id"`
	StartedAt      pgtype.Timestamptz `json:"started_at"`
	CompletedAt    pgtype.Timestamptz `json:"completed_at"`
	FailedAt       pgtype.Timestamptz `json:"failed_at"`
	OrganisationID pgtype.UUID        `json:"organisation_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

// Get the oldest pending image build and mark it as building
func (q *Queries) ImageBuildsDequeuePending(ctx context.Context) (*ImageBuildsDequeuePendingRow, error) {
	row := q.db.QueryRow(ctx, imageBuildsDequeuePending)
	var i ImageBuildsDequeuePendingRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.DeploymentID,
		&i.StartedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const imageBuildsFail = `-- name: ImageBuildsFail :one
UPDATE image_builds 
SET status = 'failed', 
    failed_at = now(), 
    updated_at = now()
WHERE id = $1
RETURNING 
    id,
    status,
    deployment_id,
    started_at,
    completed_at,
    failed_at,
    organisation_id,
    created_at,
    updated_at
`

type ImageBuildsFailRow struct {
	ID             pgtype.UUID        `json:"id"`
	Status         string             `json:"status"`
	DeploymentID   pgtype.UUID        `json:"deployment_id"`
	StartedAt      pgtype.Timestamptz `json:"started_at"`
	CompletedAt    pgtype.Timestamptz `json:"completed_at"`
	FailedAt       pgtype.Timestamptz `json:"failed_at"`
	OrganisationID pgtype.UUID        `json:"organisation_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

// Mark an image build as failed
func (q *Queries) ImageBuildsFail(ctx context.Context, id pgtype.UUID) (*ImageBuildsFailRow, error) {
	row := q.db.QueryRow(ctx, imageBuildsFail, id)
	var i ImageBuildsFailRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.DeploymentID,
		&i.StartedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.OrganisationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const imageBuildsGetByDeployment = `-- name: ImageBuildsGetByDeployment :many
SELECT 
    id,
    status,
    deployment_id,
    started_at,
    completed_at,
    failed_at,
    organisation_id,
    created_at,
    updated_at
FROM image_builds 
WHERE deployment_id = $1
ORDER BY created_at DESC
`

type ImageBuildsGetByDeploymentRow struct {
	ID             pgtype.UUID        `json:"id"`
	Status         string             `json:"status"`
	DeploymentID   pgtype.UUID        `json:"deployment_id"`
	StartedAt      pgtype.Timestamptz `json:"started_at"`
	CompletedAt    pgtype.Timestamptz `json:"completed_at"`
	FailedAt       pgtype.Timestamptz `json:"failed_at"`
	OrganisationID pgtype.UUID        `json:"organisation_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

// Get image builds for a deployment
func (q *Queries) ImageBuildsGetByDeployment(ctx context.Context, deploymentID pgtype.UUID) ([]*ImageBuildsGetByDeploymentRow, error) {
	rows, err := q.db.Query(ctx, imageBuildsGetByDeployment, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ImageBuildsGetByDeploymentRow
	for rows.Next() {
		var i ImageBuildsGetByDeploymentRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.DeploymentID,
			&i.StartedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const imageBuildsResetStale = `-- name: ImageBuildsResetStale :many
UPDATE image_builds 
SET status = 'pending',
    started_at = NULL,
    updated_at = now()
WHERE status = 'building' 
  AND started_at < NOW() - ($1 || ' minutes')::INTERVAL
RETURNING 
    id,
    status,
    deployment_id,
    started_at,
    completed_at,
    failed_at,
    organisation_id,
    created_at,
    updated_at
`

type ImageBuildsResetStaleRow struct {
	ID             pgtype.UUID        `json:"id"`
	Status         string             `json:"status"`
	DeploymentID   pgtype.UUID        `json:"deployment_id"`
	StartedAt      pgtype.Timestamptz `json:"started_at"`
	CompletedAt    pgtype.Timestamptz `json:"completed_at"`
	FailedAt       pgtype.Timestamptz `json:"failed_at"`
	OrganisationID pgtype.UUID        `json:"organisation_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

// Reset builds that have been "building" for too long (using minutes parameter)
func (q *Queries) ImageBuildsResetStale(ctx context.Context, dollar_1 pgtype.Text) ([]*ImageBuildsResetStaleRow, error) {
	rows, err := q.db.Query(ctx, imageBuildsResetStale, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ImageBuildsResetStaleRow
	for rows.Next() {
		var i ImageBuildsResetStaleRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.DeploymentID,
			&i.StartedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.OrganisationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
