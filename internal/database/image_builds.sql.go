// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: image_builds.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const imageBuildsComplete = `-- name: ImageBuildsComplete :one
UPDATE image_builds 
SET status = 'completed', 
    completed_at = now(), 
    updated_at = now()
WHERE id = $1
RETURNING 
    id,
    status,
    github_repository,
    github_commit,
    image_id,
    started_at,
    completed_at,
    failed_at,
    created_at,
    updated_at
`

type ImageBuildsCompleteRow struct {
	ID               pgtype.UUID        `json:"id"`
	Status           ImageBuildStatus   `json:"status"`
	GithubRepository string             `json:"github_repository"`
	GithubCommit     string             `json:"github_commit"`
	ImageID          pgtype.UUID        `json:"image_id"`
	StartedAt        pgtype.Timestamptz `json:"started_at"`
	CompletedAt      pgtype.Timestamptz `json:"completed_at"`
	FailedAt         pgtype.Timestamptz `json:"failed_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// Mark an image build as completed
func (q *Queries) ImageBuildsComplete(ctx context.Context, id pgtype.UUID) (*ImageBuildsCompleteRow, error) {
	row := q.db.QueryRow(ctx, imageBuildsComplete, id)
	var i ImageBuildsCompleteRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubRepository,
		&i.GithubCommit,
		&i.ImageID,
		&i.StartedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const imageBuildsCreate = `-- name: ImageBuildsCreate :one
INSERT INTO image_builds (
    id,
    status,
    github_repository,
    github_commit
) VALUES (
    $1,
    'pending',
    $2,
    $3
)
RETURNING 
    id,
    status,
    github_repository,
    github_commit,
    image_id,
    started_at,
    completed_at,
    failed_at,
    created_at,
    updated_at
`

type ImageBuildsCreateParams struct {
	ID               pgtype.UUID `json:"id"`
	GithubRepository string      `json:"github_repository"`
	GithubCommit     string      `json:"github_commit"`
}

type ImageBuildsCreateRow struct {
	ID               pgtype.UUID        `json:"id"`
	Status           ImageBuildStatus   `json:"status"`
	GithubRepository string             `json:"github_repository"`
	GithubCommit     string             `json:"github_commit"`
	ImageID          pgtype.UUID        `json:"image_id"`
	StartedAt        pgtype.Timestamptz `json:"started_at"`
	CompletedAt      pgtype.Timestamptz `json:"completed_at"`
	FailedAt         pgtype.Timestamptz `json:"failed_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// Create a new image build
func (q *Queries) ImageBuildsCreate(ctx context.Context, arg *ImageBuildsCreateParams) (*ImageBuildsCreateRow, error) {
	row := q.db.QueryRow(ctx, imageBuildsCreate, arg.ID, arg.GithubRepository, arg.GithubCommit)
	var i ImageBuildsCreateRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubRepository,
		&i.GithubCommit,
		&i.ImageID,
		&i.StartedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const imageBuildsDequeuePending = `-- name: ImageBuildsDequeuePending :one
UPDATE image_builds 
SET status = 'building', 
    started_at = now(), 
    updated_at = now()
WHERE id = (
    SELECT id 
    FROM image_builds 
    WHERE status = 'pending' 
    ORDER BY created_at ASC 
    LIMIT 1
    FOR UPDATE SKIP LOCKED
)
RETURNING 
    id,
    status,
    github_repository,
    github_commit,
    image_id,
    started_at,
    completed_at,
    failed_at,
    created_at,
    updated_at
`

type ImageBuildsDequeuePendingRow struct {
	ID               pgtype.UUID        `json:"id"`
	Status           ImageBuildStatus   `json:"status"`
	GithubRepository string             `json:"github_repository"`
	GithubCommit     string             `json:"github_commit"`
	ImageID          pgtype.UUID        `json:"image_id"`
	StartedAt        pgtype.Timestamptz `json:"started_at"`
	CompletedAt      pgtype.Timestamptz `json:"completed_at"`
	FailedAt         pgtype.Timestamptz `json:"failed_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// Get the oldest pending image build and mark it as building
func (q *Queries) ImageBuildsDequeuePending(ctx context.Context) (*ImageBuildsDequeuePendingRow, error) {
	row := q.db.QueryRow(ctx, imageBuildsDequeuePending)
	var i ImageBuildsDequeuePendingRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubRepository,
		&i.GithubCommit,
		&i.ImageID,
		&i.StartedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const imageBuildsFail = `-- name: ImageBuildsFail :one
UPDATE image_builds 
SET status = 'failed', 
    failed_at = now(), 
    updated_at = now()
WHERE id = $1
RETURNING 
    id,
    status,
    github_repository,
    github_commit,
    image_id,
    started_at,
    completed_at,
    failed_at,
    created_at,
    updated_at
`

type ImageBuildsFailRow struct {
	ID               pgtype.UUID        `json:"id"`
	Status           ImageBuildStatus   `json:"status"`
	GithubRepository string             `json:"github_repository"`
	GithubCommit     string             `json:"github_commit"`
	ImageID          pgtype.UUID        `json:"image_id"`
	StartedAt        pgtype.Timestamptz `json:"started_at"`
	CompletedAt      pgtype.Timestamptz `json:"completed_at"`
	FailedAt         pgtype.Timestamptz `json:"failed_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// Mark an image build as failed
func (q *Queries) ImageBuildsFail(ctx context.Context, id pgtype.UUID) (*ImageBuildsFailRow, error) {
	row := q.db.QueryRow(ctx, imageBuildsFail, id)
	var i ImageBuildsFailRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubRepository,
		&i.GithubCommit,
		&i.ImageID,
		&i.StartedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const imageBuildsGetById = `-- name: ImageBuildsGetById :one
SELECT 
    id,
    status,
    github_repository,
    github_commit,
    image_id,
    started_at,
    completed_at,
    failed_at,
    created_at,
    updated_at
FROM image_builds 
WHERE id = $1
`

type ImageBuildsGetByIdRow struct {
	ID               pgtype.UUID        `json:"id"`
	Status           ImageBuildStatus   `json:"status"`
	GithubRepository string             `json:"github_repository"`
	GithubCommit     string             `json:"github_commit"`
	ImageID          pgtype.UUID        `json:"image_id"`
	StartedAt        pgtype.Timestamptz `json:"started_at"`
	CompletedAt      pgtype.Timestamptz `json:"completed_at"`
	FailedAt         pgtype.Timestamptz `json:"failed_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// Get image build by ID
func (q *Queries) ImageBuildsGetById(ctx context.Context, id pgtype.UUID) (*ImageBuildsGetByIdRow, error) {
	row := q.db.QueryRow(ctx, imageBuildsGetById, id)
	var i ImageBuildsGetByIdRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.GithubRepository,
		&i.GithubCommit,
		&i.ImageID,
		&i.StartedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const imageBuildsResetStale = `-- name: ImageBuildsResetStale :many
UPDATE image_builds 
SET status = 'pending',
    started_at = NULL,
    updated_at = now()
WHERE status = 'building' 
  AND started_at < NOW() - ($1 || ' minutes')::INTERVAL
RETURNING 
    id,
    status,
    github_repository,
    github_commit,
    image_id,
    started_at,
    completed_at,
    failed_at,
    created_at,
    updated_at
`

type ImageBuildsResetStaleRow struct {
	ID               pgtype.UUID        `json:"id"`
	Status           ImageBuildStatus   `json:"status"`
	GithubRepository string             `json:"github_repository"`
	GithubCommit     string             `json:"github_commit"`
	ImageID          pgtype.UUID        `json:"image_id"`
	StartedAt        pgtype.Timestamptz `json:"started_at"`
	CompletedAt      pgtype.Timestamptz `json:"completed_at"`
	FailedAt         pgtype.Timestamptz `json:"failed_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// Reset builds that have been "building" for too long (using minutes parameter)
func (q *Queries) ImageBuildsResetStale(ctx context.Context, dollar_1 pgtype.Text) ([]*ImageBuildsResetStaleRow, error) {
	rows, err := q.db.Query(ctx, imageBuildsResetStale, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ImageBuildsResetStaleRow
	for rows.Next() {
		var i ImageBuildsResetStaleRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.GithubRepository,
			&i.GithubCommit,
			&i.ImageID,
			&i.StartedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
