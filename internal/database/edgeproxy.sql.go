// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: edgeproxy.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acquireCertmagicLock = `-- name: AcquireCertmagicLock :execrows
INSERT INTO certmagic_locks (key, expires)
VALUES ($1, $2)
ON CONFLICT (key) 
DO UPDATE SET expires = EXCLUDED.expires
WHERE certmagic_locks.expires < NOW()
`

type AcquireCertmagicLockParams struct {
	Key     string             `json:"key"`
	Expires pgtype.Timestamptz `json:"expires"`
}

// Attempts to acquire a lock for a key
func (q *Queries) AcquireCertmagicLock(ctx context.Context, arg *AcquireCertmagicLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, acquireCertmagicLock, arg.Key, arg.Expires)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const cleanupExpiredCertmagicLocks = `-- name: CleanupExpiredCertmagicLocks :exec
DELETE FROM certmagic_locks
WHERE expires < NOW()
`

// Removes expired locks
func (q *Queries) CleanupExpiredCertmagicLocks(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredCertmagicLocks)
	return err
}

const deleteCertmagicData = `-- name: DeleteCertmagicData :execrows
DELETE FROM certmagic_data
WHERE key = $1
`

// Deletes a certmagic data entry by key
func (q *Queries) DeleteCertmagicData(ctx context.Context, key string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteCertmagicData, key)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const existsCertmagicData = `-- name: ExistsCertmagicData :one
SELECT EXISTS(SELECT 1 FROM certmagic_data WHERE key = $1)
`

// Checks if a certmagic data entry exists
func (q *Queries) ExistsCertmagicData(ctx context.Context, key string) (bool, error) {
	row := q.db.QueryRow(ctx, existsCertmagicData, key)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getActiveRoutes = `-- name: GetActiveRoutes :many
SELECT 
    d.name as domain_name,
    v.public_ip as vm_public_ip,
    v.port as vm_port,
    v.region_id as vm_region_id,
    r.load_balancer_ipv4 as region_load_balancer_ip
FROM domains d
INNER JOIN deployments dep ON d.deployment_id = dep.id
INNER JOIN vms v ON dep.vm_id = v.id
INNER JOIN regions r ON v.region_id = r.id
WHERE d.verified_at IS NOT NULL
  AND dep.status = 'ready'
  AND v.status = 'running'
ORDER BY d.name
`

type GetActiveRoutesRow struct {
	DomainName           string      `json:"domain_name"`
	VmPublicIp           pgtype.Text `json:"vm_public_ip"`
	VmPort               int32       `json:"vm_port"`
	VmRegionID           pgtype.UUID `json:"vm_region_id"`
	RegionLoadBalancerIp string      `json:"region_load_balancer_ip"`
}

// Returns active routing information for the edgeproxy
// Joins domains → deployments → vms → regions
func (q *Queries) GetActiveRoutes(ctx context.Context) ([]*GetActiveRoutesRow, error) {
	rows, err := q.db.Query(ctx, getActiveRoutes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetActiveRoutesRow
	for rows.Next() {
		var i GetActiveRoutesRow
		if err := rows.Scan(
			&i.DomainName,
			&i.VmPublicIp,
			&i.VmPort,
			&i.VmRegionID,
			&i.RegionLoadBalancerIp,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDomainsNeedingCertificates = `-- name: GetDomainsNeedingCertificates :many
SELECT 
    id,
    name,
    ssl_certificate_status,
    ssl_certificate_expires_at
FROM domains
WHERE verified_at IS NOT NULL
  AND (
    ssl_certificate_status IS NULL 
    OR ssl_certificate_status != 'active'
    OR ssl_certificate_expires_at IS NULL
    OR ssl_certificate_expires_at < NOW() + INTERVAL '30 days'
  )
ORDER BY name
`

type GetDomainsNeedingCertificatesRow struct {
	ID                      pgtype.UUID                `json:"id"`
	Name                    string                     `json:"name"`
	SslCertificateStatus    NullSslCertificateStatuses `json:"ssl_certificate_status"`
	SslCertificateExpiresAt pgtype.Timestamptz         `json:"ssl_certificate_expires_at"`
}

// Returns domains that need SSL certificates (verified but not yet active)
func (q *Queries) GetDomainsNeedingCertificates(ctx context.Context) ([]*GetDomainsNeedingCertificatesRow, error) {
	rows, err := q.db.Query(ctx, getDomainsNeedingCertificates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetDomainsNeedingCertificatesRow
	for rows.Next() {
		var i GetDomainsNeedingCertificatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.SslCertificateStatus,
			&i.SslCertificateExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCertmagicDataNonRecursive = `-- name: ListCertmagicDataNonRecursive :many
SELECT key
FROM certmagic_data
WHERE key LIKE $1 || '%'
  AND position('/' in substring(key from length($1) + 1)) = 0
ORDER BY key
`

// Lists certmagic data keys with a given prefix (non-recursive - no additional slashes)
func (q *Queries) ListCertmagicDataNonRecursive(ctx context.Context, dollar_1 pgtype.Text) ([]string, error) {
	rows, err := q.db.Query(ctx, listCertmagicDataNonRecursive, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCertmagicDataRecursive = `-- name: ListCertmagicDataRecursive :many
SELECT key
FROM certmagic_data
WHERE key LIKE $1 || '%'
ORDER BY key
`

// Lists all certmagic data keys with a given prefix (recursive)
func (q *Queries) ListCertmagicDataRecursive(ctx context.Context, dollar_1 pgtype.Text) ([]string, error) {
	rows, err := q.db.Query(ctx, listCertmagicDataRecursive, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadCertmagicData = `-- name: LoadCertmagicData :one
SELECT key, value, modified
FROM certmagic_data
WHERE key = $1
`

// Loads a certmagic data entry by key
func (q *Queries) LoadCertmagicData(ctx context.Context, key string) (*CertmagicDatum, error) {
	row := q.db.QueryRow(ctx, loadCertmagicData, key)
	var i CertmagicDatum
	err := row.Scan(&i.Key, &i.Value, &i.Modified)
	return &i, err
}

const releaseCertmagicLock = `-- name: ReleaseCertmagicLock :execrows
DELETE FROM certmagic_locks
WHERE key = $1
`

// Releases a lock for a key
func (q *Queries) ReleaseCertmagicLock(ctx context.Context, key string) (int64, error) {
	result, err := q.db.Exec(ctx, releaseCertmagicLock, key)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const statCertmagicData = `-- name: StatCertmagicData :one
SELECT key, value, modified
FROM certmagic_data
WHERE key = $1
`

// Returns metadata about a certmagic data entry
func (q *Queries) StatCertmagicData(ctx context.Context, key string) (*CertmagicDatum, error) {
	row := q.db.QueryRow(ctx, statCertmagicData, key)
	var i CertmagicDatum
	err := row.Scan(&i.Key, &i.Value, &i.Modified)
	return &i, err
}

const storeCertmagicData = `-- name: StoreCertmagicData :exec

INSERT INTO certmagic_data (key, value, modified)
VALUES ($1, $2, $3)
ON CONFLICT (key)
DO UPDATE SET 
    value = EXCLUDED.value, 
    modified = EXCLUDED.modified
`

type StoreCertmagicDataParams struct {
	Key      string             `json:"key"`
	Value    string             `json:"value"`
	Modified pgtype.Timestamptz `json:"modified"`
}

// Certmagic Storage Queries
// Stores or updates a certmagic data entry
func (q *Queries) StoreCertmagicData(ctx context.Context, arg *StoreCertmagicDataParams) error {
	_, err := q.db.Exec(ctx, storeCertmagicData, arg.Key, arg.Value, arg.Modified)
	return err
}

const updateDomainCertificateStatus = `-- name: UpdateDomainCertificateStatus :exec
UPDATE domains
SET 
    ssl_certificate_status = $2,
    ssl_certificate_issued_at = $3,
    ssl_certificate_expires_at = $4,
    ssl_certificate_error = $5,
    updated_at = NOW()
WHERE id = $1
`

type UpdateDomainCertificateStatusParams struct {
	ID                      pgtype.UUID                `json:"id"`
	SslCertificateStatus    NullSslCertificateStatuses `json:"ssl_certificate_status"`
	SslCertificateIssuedAt  pgtype.Timestamptz         `json:"ssl_certificate_issued_at"`
	SslCertificateExpiresAt pgtype.Timestamptz         `json:"ssl_certificate_expires_at"`
	SslCertificateError     pgtype.Text                `json:"ssl_certificate_error"`
}

// Updates the SSL certificate status for a domain
func (q *Queries) UpdateDomainCertificateStatus(ctx context.Context, arg *UpdateDomainCertificateStatusParams) error {
	_, err := q.db.Exec(ctx, updateDomainCertificateStatus,
		arg.ID,
		arg.SslCertificateStatus,
		arg.SslCertificateIssuedAt,
		arg.SslCertificateExpiresAt,
		arg.SslCertificateError,
	)
	return err
}
