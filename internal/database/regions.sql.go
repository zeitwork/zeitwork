// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: regions.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const regionCreate = `-- name: RegionCreate :one
INSERT INTO regions (name, code, country) VALUES ($1, $2, $3) RETURNING id, name, code, country, created_at, updated_at, deleted_at
`

type RegionCreateParams struct {
	Name    string `json:"name"`
	Code    string `json:"code"`
	Country string `json:"country"`
}

func (q *Queries) RegionCreate(ctx context.Context, arg *RegionCreateParams) (*Region, error) {
	row := q.db.QueryRow(ctx, regionCreate, arg.Name, arg.Code, arg.Country)
	var i Region
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Country,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const regionDelete = `-- name: RegionDelete :exec
DELETE FROM regions WHERE id = $1
`

func (q *Queries) RegionDelete(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, regionDelete, id)
	return err
}

const regionFind = `-- name: RegionFind :many
SELECT id, name, code, country, created_at, updated_at, deleted_at FROM regions ORDER BY name
`

func (q *Queries) RegionFind(ctx context.Context) ([]*Region, error) {
	rows, err := q.db.Query(ctx, regionFind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Region
	for rows.Next() {
		var i Region
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.Country,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const regionFindByCode = `-- name: RegionFindByCode :one
SELECT id, name, code, country, created_at, updated_at, deleted_at FROM regions WHERE code = $1
`

func (q *Queries) RegionFindByCode(ctx context.Context, code string) (*Region, error) {
	row := q.db.QueryRow(ctx, regionFindByCode, code)
	var i Region
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Country,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const regionFindByCountry = `-- name: RegionFindByCountry :many
SELECT id, name, code, country, created_at, updated_at, deleted_at FROM regions WHERE country = $1 ORDER BY name
`

func (q *Queries) RegionFindByCountry(ctx context.Context, country string) ([]*Region, error) {
	rows, err := q.db.Query(ctx, regionFindByCountry, country)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Region
	for rows.Next() {
		var i Region
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.Country,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const regionFindById = `-- name: RegionFindById :one
SELECT id, name, code, country, created_at, updated_at, deleted_at FROM regions WHERE id = $1
`

func (q *Queries) RegionFindById(ctx context.Context, id pgtype.UUID) (*Region, error) {
	row := q.db.QueryRow(ctx, regionFindById, id)
	var i Region
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Country,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const regionUpdate = `-- name: RegionUpdate :one
UPDATE regions SET name = $2, code = $3, country = $4, updated_at = NOW() WHERE id = $1 RETURNING id, name, code, country, created_at, updated_at, deleted_at
`

type RegionUpdateParams struct {
	ID      pgtype.UUID `json:"id"`
	Name    string      `json:"name"`
	Code    string      `json:"code"`
	Country string      `json:"country"`
}

func (q *Queries) RegionUpdate(ctx context.Context, arg *RegionUpdateParams) (*Region, error) {
	row := q.db.QueryRow(ctx, regionUpdate,
		arg.ID,
		arg.Name,
		arg.Code,
		arg.Country,
	)
	var i Region
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.Country,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
