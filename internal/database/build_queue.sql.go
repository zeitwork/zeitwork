// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: build_queue.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const buildQueueComplete = `-- name: BuildQueueComplete :one
UPDATE build_queue 
SET status = 'completed', build_completed_at = NOW(), build_log = $2, updated_at = NOW() 
WHERE id = $1 RETURNING id, project_id, image_id, priority, status, github_repo, commit_hash, branch, build_started_at, build_completed_at, build_log, created_at, updated_at, deleted_at
`

type BuildQueueCompleteParams struct {
	ID       pgtype.UUID `json:"id"`
	BuildLog pgtype.Text `json:"build_log"`
}

func (q *Queries) BuildQueueComplete(ctx context.Context, arg *BuildQueueCompleteParams) (*BuildQueue, error) {
	row := q.db.QueryRow(ctx, buildQueueComplete, arg.ID, arg.BuildLog)
	var i BuildQueue
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ImageID,
		&i.Priority,
		&i.Status,
		&i.GithubRepo,
		&i.CommitHash,
		&i.Branch,
		&i.BuildStartedAt,
		&i.BuildCompletedAt,
		&i.BuildLog,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const buildQueueCreate = `-- name: BuildQueueCreate :one
INSERT INTO build_queue (project_id, image_id, priority, status, github_repo, commit_hash, branch) 
VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, project_id, image_id, priority, status, github_repo, commit_hash, branch, build_started_at, build_completed_at, build_log, created_at, updated_at, deleted_at
`

type BuildQueueCreateParams struct {
	ProjectID  pgtype.UUID `json:"project_id"`
	ImageID    pgtype.UUID `json:"image_id"`
	Priority   int32       `json:"priority"`
	Status     string      `json:"status"`
	GithubRepo string      `json:"github_repo"`
	CommitHash string      `json:"commit_hash"`
	Branch     string      `json:"branch"`
}

func (q *Queries) BuildQueueCreate(ctx context.Context, arg *BuildQueueCreateParams) (*BuildQueue, error) {
	row := q.db.QueryRow(ctx, buildQueueCreate,
		arg.ProjectID,
		arg.ImageID,
		arg.Priority,
		arg.Status,
		arg.GithubRepo,
		arg.CommitHash,
		arg.Branch,
	)
	var i BuildQueue
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ImageID,
		&i.Priority,
		&i.Status,
		&i.GithubRepo,
		&i.CommitHash,
		&i.Branch,
		&i.BuildStartedAt,
		&i.BuildCompletedAt,
		&i.BuildLog,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const buildQueueDelete = `-- name: BuildQueueDelete :exec
DELETE FROM build_queue WHERE id = $1
`

func (q *Queries) BuildQueueDelete(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, buildQueueDelete, id)
	return err
}

const buildQueueDequeuePending = `-- name: BuildQueueDequeuePending :one
UPDATE build_queue 
SET status = 'processing', build_started_at = NOW(), updated_at = NOW()
WHERE id = (
    SELECT id FROM build_queue 
    WHERE status = 'pending' 
    ORDER BY priority DESC, created_at ASC 
    LIMIT 1 
    FOR UPDATE SKIP LOCKED
)
RETURNING id, project_id, image_id, priority, status, github_repo, commit_hash, branch, build_started_at, build_completed_at, build_log, created_at, updated_at, deleted_at
`

func (q *Queries) BuildQueueDequeuePending(ctx context.Context) (*BuildQueue, error) {
	row := q.db.QueryRow(ctx, buildQueueDequeuePending)
	var i BuildQueue
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ImageID,
		&i.Priority,
		&i.Status,
		&i.GithubRepo,
		&i.CommitHash,
		&i.Branch,
		&i.BuildStartedAt,
		&i.BuildCompletedAt,
		&i.BuildLog,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const buildQueueFail = `-- name: BuildQueueFail :one
UPDATE build_queue 
SET status = 'failed', build_completed_at = NOW(), build_log = $2, updated_at = NOW() 
WHERE id = $1 RETURNING id, project_id, image_id, priority, status, github_repo, commit_hash, branch, build_started_at, build_completed_at, build_log, created_at, updated_at, deleted_at
`

type BuildQueueFailParams struct {
	ID       pgtype.UUID `json:"id"`
	BuildLog pgtype.Text `json:"build_log"`
}

func (q *Queries) BuildQueueFail(ctx context.Context, arg *BuildQueueFailParams) (*BuildQueue, error) {
	row := q.db.QueryRow(ctx, buildQueueFail, arg.ID, arg.BuildLog)
	var i BuildQueue
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ImageID,
		&i.Priority,
		&i.Status,
		&i.GithubRepo,
		&i.CommitHash,
		&i.Branch,
		&i.BuildStartedAt,
		&i.BuildCompletedAt,
		&i.BuildLog,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const buildQueueFindById = `-- name: BuildQueueFindById :one
SELECT id, project_id, image_id, priority, status, github_repo, commit_hash, branch, build_started_at, build_completed_at, build_log, created_at, updated_at, deleted_at FROM build_queue WHERE id = $1
`

func (q *Queries) BuildQueueFindById(ctx context.Context, id pgtype.UUID) (*BuildQueue, error) {
	row := q.db.QueryRow(ctx, buildQueueFindById, id)
	var i BuildQueue
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ImageID,
		&i.Priority,
		&i.Status,
		&i.GithubRepo,
		&i.CommitHash,
		&i.Branch,
		&i.BuildStartedAt,
		&i.BuildCompletedAt,
		&i.BuildLog,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const buildQueueFindByImage = `-- name: BuildQueueFindByImage :one
SELECT id, project_id, image_id, priority, status, github_repo, commit_hash, branch, build_started_at, build_completed_at, build_log, created_at, updated_at, deleted_at FROM build_queue WHERE image_id = $1
`

func (q *Queries) BuildQueueFindByImage(ctx context.Context, imageID pgtype.UUID) (*BuildQueue, error) {
	row := q.db.QueryRow(ctx, buildQueueFindByImage, imageID)
	var i BuildQueue
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ImageID,
		&i.Priority,
		&i.Status,
		&i.GithubRepo,
		&i.CommitHash,
		&i.Branch,
		&i.BuildStartedAt,
		&i.BuildCompletedAt,
		&i.BuildLog,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const buildQueueFindByProject = `-- name: BuildQueueFindByProject :many
SELECT id, project_id, image_id, priority, status, github_repo, commit_hash, branch, build_started_at, build_completed_at, build_log, created_at, updated_at, deleted_at FROM build_queue WHERE project_id = $1 ORDER BY created_at DESC
`

func (q *Queries) BuildQueueFindByProject(ctx context.Context, projectID pgtype.UUID) ([]*BuildQueue, error) {
	rows, err := q.db.Query(ctx, buildQueueFindByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*BuildQueue
	for rows.Next() {
		var i BuildQueue
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ImageID,
			&i.Priority,
			&i.Status,
			&i.GithubRepo,
			&i.CommitHash,
			&i.Branch,
			&i.BuildStartedAt,
			&i.BuildCompletedAt,
			&i.BuildLog,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const buildQueueFindPending = `-- name: BuildQueueFindPending :many
SELECT id, project_id, image_id, priority, status, github_repo, commit_hash, branch, build_started_at, build_completed_at, build_log, created_at, updated_at, deleted_at FROM build_queue 
WHERE status = 'pending' 
ORDER BY priority DESC, created_at ASC
`

func (q *Queries) BuildQueueFindPending(ctx context.Context) ([]*BuildQueue, error) {
	rows, err := q.db.Query(ctx, buildQueueFindPending)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*BuildQueue
	for rows.Next() {
		var i BuildQueue
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ImageID,
			&i.Priority,
			&i.Status,
			&i.GithubRepo,
			&i.CommitHash,
			&i.Branch,
			&i.BuildStartedAt,
			&i.BuildCompletedAt,
			&i.BuildLog,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const buildQueueUpdateStatus = `-- name: BuildQueueUpdateStatus :one
UPDATE build_queue 
SET status = $2, updated_at = NOW() 
WHERE id = $1 RETURNING id, project_id, image_id, priority, status, github_repo, commit_hash, branch, build_started_at, build_completed_at, build_log, created_at, updated_at, deleted_at
`

type BuildQueueUpdateStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) BuildQueueUpdateStatus(ctx context.Context, arg *BuildQueueUpdateStatusParams) (*BuildQueue, error) {
	row := q.db.QueryRow(ctx, buildQueueUpdateStatus, arg.ID, arg.Status)
	var i BuildQueue
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ImageID,
		&i.Priority,
		&i.Status,
		&i.GithubRepo,
		&i.CommitHash,
		&i.Branch,
		&i.BuildStartedAt,
		&i.BuildCompletedAt,
		&i.BuildLog,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
