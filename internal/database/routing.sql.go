// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: routing.sql

package database

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const routingCacheCleanup = `-- name: RoutingCacheCleanup :exec
DELETE FROM routing_cache 
WHERE updated_at < NOW() - INTERVAL '24 hours'
`

// Remove entries older than 24 hours
func (q *Queries) RoutingCacheCleanup(ctx context.Context) error {
	_, err := q.db.Exec(ctx, routingCacheCleanup)
	return err
}

const routingCacheDeleteByDeployment = `-- name: RoutingCacheDeleteByDeployment :exec
DELETE FROM routing_cache WHERE deployment_id = $1
`

func (q *Queries) RoutingCacheDeleteByDeployment(ctx context.Context, deploymentID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, routingCacheDeleteByDeployment, deploymentID)
	return err
}

const routingCacheDeleteByDomain = `-- name: RoutingCacheDeleteByDomain :exec
DELETE FROM routing_cache WHERE domain = $1
`

func (q *Queries) RoutingCacheDeleteByDomain(ctx context.Context, domain string) error {
	_, err := q.db.Exec(ctx, routingCacheDeleteByDomain, domain)
	return err
}

const routingCacheFindByDeployment = `-- name: RoutingCacheFindByDeployment :many
SELECT id, domain, deployment_id, instances, version, created_at, updated_at, deleted_at FROM routing_cache WHERE deployment_id = $1
`

func (q *Queries) RoutingCacheFindByDeployment(ctx context.Context, deploymentID pgtype.UUID) ([]*RoutingCache, error) {
	rows, err := q.db.Query(ctx, routingCacheFindByDeployment, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RoutingCache
	for rows.Next() {
		var i RoutingCache
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.DeploymentID,
			&i.Instances,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const routingCacheFindByDomain = `-- name: RoutingCacheFindByDomain :one
SELECT id, domain, deployment_id, instances, version, created_at, updated_at, deleted_at FROM routing_cache WHERE domain = $1
`

func (q *Queries) RoutingCacheFindByDomain(ctx context.Context, domain string) (*RoutingCache, error) {
	row := q.db.QueryRow(ctx, routingCacheFindByDomain, domain)
	var i RoutingCache
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.DeploymentID,
		&i.Instances,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const routingCacheUpsert = `-- name: RoutingCacheUpsert :one
INSERT INTO routing_cache (
    domain, 
    deployment_id, 
    instances,
    version
) VALUES (
    $1, $2, $3, $4
)
ON CONFLICT (domain) 
DO UPDATE SET 
    deployment_id = EXCLUDED.deployment_id,
    instances = EXCLUDED.instances,
    version = EXCLUDED.version,
    updated_at = NOW()
RETURNING id, domain, deployment_id, instances, version, created_at, updated_at, deleted_at
`

type RoutingCacheUpsertParams struct {
	Domain       string          `json:"domain"`
	DeploymentID pgtype.UUID     `json:"deployment_id"`
	Instances    json.RawMessage `json:"instances"`
	Version      int32           `json:"version"`
}

func (q *Queries) RoutingCacheUpsert(ctx context.Context, arg *RoutingCacheUpsertParams) (*RoutingCache, error) {
	row := q.db.QueryRow(ctx, routingCacheUpsert,
		arg.Domain,
		arg.DeploymentID,
		arg.Instances,
		arg.Version,
	)
	var i RoutingCache
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.DeploymentID,
		&i.Instances,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
